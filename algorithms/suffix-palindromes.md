---
title: 后缀回文问题
---

# 后缀回文问题
>本问题摘自CodeChef。原题链接https://www.codechef.com/problems/SFXPAL

**问题**：考虑一个大小为`S`的字符集，求所有满足下列条件的字符串的个数：由这个字符集中的字符组成，长度为`N`，不存在长度超过1的回文后缀。

*输入：整数`N`，`S`和`M`。*

*输出：满足条件的字符串的个数，模`M`。*

*样例输入*：

```
3 3 13
```

*样例输出*：

```
12
```

**思路**：假如已经有了长度为`N-1`的满足条件的字符串的个数，怎样找出长度为`N`的个数？

显然，如果把一个长度为`N`的不存在回文后缀的字符串去掉第一个字符，得到的一定是不存在回文后缀的长度为`N-1`的字符串。所以，设满足条件的长度为`N`的字符串个数为`F[N]`，对每个长度为`N-1`的满足条件的字符串，分别在前面添加`S`个不同字符，得到的`F[N-1]*S`个字符串的集合，就包含了所有满足条件的长度为`N`的字符串。把这个集合记为`A`。现在的问题是怎样找到`A`中不满足条件的字符串，求出它们的个数？

容易验证，`A`中不满足条件的字符串子集等价于满足下面条件的字符串的集合：

1. 长度为`N`
2. 本身是回文；除此之外，不存在长度超过1的回文后缀

当`N>=2`时，`A`和满足下面条件的字符串集合（记为`B`）存在一一映射：

1. 长度为`ceil(N/2)`
2. 不存在长度超过1的回文后缀

映射定义如下：对`A`中的字符串，取其长度为`ceil(N/2)`的前缀，就得到了`B`中的字符串；反过来，对`B`中的字符串，将其长度为`floor(N/2)`的前缀翻转拼接到该字符串后面，就得到了`A`中的字符串。

因此，`|A|=|B|`，而`B`正是长度为`ceil(N/2)`的满足条件的字符串的集合。因此`|A|=F[ceil(N/2)]`。于是`F[N]=F[N-1]*S-F[ceil(N/2)]`。

**代码**：[https://github.com/yczhangsjtu/Algorithms/blob/master/codechef/suffix-palindromes.cpp](https://github.com/yczhangsjtu/Algorithms/blob/master/codechef/suffix-palindromes.cpp)

