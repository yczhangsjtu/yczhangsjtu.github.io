---
title: KMP算法
---

# KMP算法

KMP是求解字符串模式匹配的经典算法。

**问题**：给定字符串`p`，和字符串`s`，找出所有在`s`中出现的`p`的位置。

**解决步骤**：

1. 求出`p`的NEXT数组；
2. 将`p`的左端和`s`的左端对齐；
3. 将对齐点向右移动，逐个字符比较，直到对齐点右边的字符不同（包括对齐点走到`p`尾部的情况）；
4. 将`p`向右移动，移动的距离由NEXT数组给出，对齐点不变，继续步骤3；
5. 输出所有对齐点走到`p`尾部时`p`的位置。

**KMP算法的思想**：

最简单的字符串匹配算法是，先将两个字符串最左端对齐，然后移动对齐点，直到走到`p`的尾部或右边的字符不同，此时将`p`向右移动一位，将对齐点移回`p`的开头，然后继续。

![string-match](/assets/images/string-match.png)

可以看到，KMP算法和这个最简单的算法相比，做了两个加速：首先，`p`不只移动一位；其次，对齐点不变。

之所以能够做出这样的加速，源自于以下考虑：当发现一个字符不匹配时，前面已经匹配了许多字符了。能否利用这一事实带来的信息，省略掉一些重复的工作？比如，假设`p`在`s`的某个位置上匹配了前四个字符，第五个字符不匹配了，这时需要移动`p`。如果预先知道`p`的前四个字符两两不同，那就可以将`p`直接向后移动四位，然后从`p`的头部开始匹配。

![kmp-match](/assets/images/kmp-match.png)

而如果`p`的前四个字符是`ABAB`型的，就可以将`p`向后移动两位，然后从`p`的第三个字符开始继续比较。

![kmp-match-abab](/assets/images/kmp-match-abab.png)

总结一下规律：观察模式字符串`p`中已经匹配过的部分，如果这部分有前缀和后缀相同，就可以把`p`向右移动，让前缀移动到后缀原位置。如果有多组相同的前缀和后缀，就取较长的后缀，即移动更短的距离。

把模式字符串的每个前缀，求出这样一对相等的前后缀的长度，就得到了NEXT数组。

**求解NEXT数组**：首先，将`NEXT[0]`定义为-1。容易求出`NEXT[1]=0`，因为长度为1的字符串没有相等的前后缀。

然后，用动态规划，假设已经求出了`NEXT[k]`，现在求`NEXT[k+1]`。注意到，如果将长度为`k+1`的前缀中，找到的长度为`NEXT[k+1]`的相等的前后缀，各自去掉最后一个字符，就得到了长度为`k`的前缀的长度相等的前后缀。因此`NEXT[k+1]`最多比`NEXT[k]`多一。

![solve-next](/assets/images/solve-next.png)

现在，将已经匹配的前`NEXT[K]`个字符和后`NEXT[k]`个字符对齐，如下。

![solve-next-2](/assets/images/solve-next-2.png)

如果对齐点右边的字符相等，就立刻得到`NEXT[k+1]=NEXT[k]+1`。

如果不相等，就像寻找字符串匹配一样，利用已经求出的NEXT数组的部分，继续将下面的字符串往右跳跃。如下示例

![solve-next-3](/assets/images/solve-next-3.png)

**代码**：[https://github.com/yczhangsjtu/Algorithms/blob/master/hihocoder/kmp.cpp](https://github.com/yczhangsjtu/Algorithms/blob/master/hihocoder/kmp.cpp)

