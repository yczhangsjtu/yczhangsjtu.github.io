---
title: User Defined C Module
---

# User Defined C Module for Python
Here is an example of the build of a user defined shpfile module written
in C.

## The C program

```c
#include <Python.h>

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <string.h>

#define MAX_FILE_NAME 256

typedef unsigned char BYTE;
typedef short int WORD;
typedef int LONGINT;

typedef struct Color {
    BYTE c[4];
} Color;

typedef struct FileHeader {
    WORD check;
    WORD width;
    WORD height;
    WORD num;
} FileHeader;

typedef struct ImageHeader {
    WORD x,y,w,h;
    BYTE compression;
    BYTE align[3];
    Color transparent;
    LONGINT zero,offset;
} ImageHeader;

typedef struct ImageData {
    ImageHeader header;
    BYTE * data;
} ImageData;

typedef struct Image {
    LONGINT w,h;
    BYTE *data;
} Image;

void allocImageData(ImageData *imageData)
{
    LONGINT size = imageData->header.w * imageData->header.h;
    imageData->data = (BYTE*)malloc(size * sizeof(LONGINT));
}

void freeImageData(ImageData *imageData)
{
    free(imageData->data);
    imageData->data = NULL;
}

void decompress1(BYTE *dst, BYTE *src, WORD w, WORD h)
{
    memcpy(dst,src,w*h);
}
void decompress2(BYTE *dst, BYTE *src, WORD w, WORD h)
{

}
void decompress3(BYTE *dst, BYTE *src, WORD w, WORD h)
{
    BYTE *psrc = src, *pdst = dst;
    BYTE v;
    WORD pos, count, x, y, i;
    for(y = 0; y < h; y++)
    {
        pos = *((WORD*)psrc);
        count = pos-2;
        psrc += 2;
        x = 0;
        for(i = 0; i < count; i++)
        {
            v = *psrc++;
            if(v)
            {
                *pdst++ = v;
                x++;
            }
            else
            {
                v = *psrc++;
                i++;
                while(v > 0 && x < w)
                {
                    *pdst++ = 0;
                    x++;
                    v--;
                }
            }
        }
        assert(x == w);
    }
}

BYTE defaultPalatte[][3] =
{
    {0x00,0x00,0x00}, {0x2a,0x00,0x2a}, {0x00,0x2a,0x2a}, {0x00,0x2a,0x00},
    {0x15,0x3f,0x15}, {0x3f,0x3f,0x15}, {0x3f,0x15,0x15}, {0x2a,0x15,0x00},
    {0x2a,0x00,0x00}, {0x15,0x3f,0x3f}, {0x14,0x14,0x3f}, {0x00,0x00,0x2a},
    {0x00,0x00,0x00}, {0x15,0x15,0x15}, {0x2a,0x2a,0x2a}, {0x3f,0x3f,0x3f},
    {0x3f,0x00,0x00}, {0x3b,0x00,0x00}, {0x37,0x00,0x00}, {0x34,0x00,0x00},
    {0x30,0x00,0x00}, {0x2c,0x00,0x00}, {0x29,0x00,0x00}, {0x25,0x00,0x00},
    {0x21,0x00,0x00}, {0x1e,0x00,0x00}, {0x1a,0x00,0x00}, {0x16,0x00,0x00},
    {0x13,0x00,0x00}, {0x0f,0x00,0x00}, {0x0b,0x00,0x00}, {0x08,0x00,0x00},
    {0x3f,0x3f,0x3f}, {0x3d,0x3d,0x3d}, {0x3b,0x3b,0x3b}, {0x38,0x38,0x38},
    {0x36,0x36,0x36}, {0x34,0x34,0x34}, {0x32,0x32,0x32}, {0x30,0x30,0x30},
    {0x2e,0x2e,0x2e}, {0x2c,0x2c,0x2c}, {0x2a,0x2a,0x2a}, {0x28,0x28,0x28},
    {0x26,0x26,0x26}, {0x24,0x24,0x24}, {0x22,0x22,0x22}, {0x20,0x20,0x20},
    {0x1e,0x1e,0x1e}, {0x1c,0x1c,0x1c}, {0x1a,0x1a,0x1a}, {0x18,0x18,0x18},
    {0x15,0x15,0x15}, {0x13,0x13,0x13}, {0x11,0x11,0x11}, {0x0f,0x0f,0x0f},
    {0x0d,0x0d,0x0d}, {0x0b,0x0b,0x0b}, {0x09,0x09,0x09}, {0x07,0x07,0x07},
    {0x05,0x05,0x05}, {0x03,0x03,0x03}, {0x01,0x01,0x01}, {0x00,0x00,0x00},
    {0x34,0x34,0x2e}, {0x31,0x31,0x2b}, {0x2e,0x2e,0x28}, {0x2b,0x2b,0x25},
    {0x28,0x28,0x22}, {0x25,0x25,0x1f}, {0x22,0x22,0x1c}, {0x1f,0x1f,0x19},
    {0x1c,0x1c,0x16}, {0x19,0x19,0x13}, {0x16,0x16,0x10}, {0x13,0x13,0x0d},
    {0x10,0x10,0x0a}, {0x0d,0x0d,0x07}, {0x0a,0x0a,0x04}, {0x07,0x07,0x01},
    {0x37,0x37,0x3d}, {0x34,0x34,0x3a}, {0x31,0x31,0x37}, {0x2e,0x2e,0x34},
    {0x2b,0x2b,0x31}, {0x28,0x28,0x2e}, {0x25,0x25,0x2b}, {0x22,0x22,0x28},
    {0x1f,0x1f,0x25}, {0x1c,0x1c,0x22}, {0x19,0x19,0x1f}, {0x16,0x16,0x1c},
    {0x13,0x13,0x19}, {0x10,0x10,0x16}, {0x0d,0x0d,0x13}, {0x0a,0x0a,0x10},
    {0x3b,0x2f,0x2b}, {0x38,0x2c,0x28}, {0x35,0x29,0x25}, {0x32,0x26,0x22},
    {0x2f,0x23,0x1f}, {0x2c,0x20,0x1c}, {0x29,0x1d,0x19}, {0x26,0x1a,0x16},
    {0x23,0x17,0x13}, {0x20,0x14,0x10}, {0x1d,0x11,0x0d}, {0x1a,0x0e,0x0a},
    {0x17,0x0b,0x07}, {0x14,0x08,0x04}, {0x11,0x05,0x01}, {0x0d,0x01,0x00},
    {0x22,0x20,0x16}, {0x20,0x1e,0x15}, {0x1e,0x1d,0x14}, {0x1d,0x1b,0x13},
    {0x1c,0x1a,0x12}, {0x1a,0x18,0x11}, {0x18,0x16,0x10}, {0x16,0x14,0x0f},
    {0x14,0x12,0x0e}, {0x12,0x10,0x0c}, {0x0e,0x0e,0x0a}, {0x0c,0x0c,0x09},
    {0x0b,0x0b,0x08}, {0x0a,0x0a,0x07}, {0x08,0x08,0x05}, {0x06,0x06,0x03},
    {0x35,0x2f,0x1e}, {0x33,0x2d,0x1c}, {0x31,0x2b,0x1c}, {0x2f,0x29,0x1a},
    {0x2b,0x27,0x1a}, {0x29,0x25,0x18}, {0x27,0x23,0x16}, {0x25,0x21,0x14},
    {0x23,0x1e,0x14}, {0x21,0x1c,0x12}, {0x1e,0x1a,0x10}, {0x1c,0x18,0x0f},
    {0x1a,0x18,0x12}, {0x19,0x17,0x11}, {0x18,0x16,0x10}, {0x17,0x15,0x10},
    {0x2f,0x24,0x0f}, {0x2c,0x23,0x0e}, {0x29,0x21,0x0e}, {0x26,0x1e,0x0e},
    {0x23,0x1c,0x0e}, {0x21,0x1b,0x0e}, {0x1e,0x19,0x0e}, {0x1c,0x17,0x0c},
    {0x1b,0x16,0x0b}, {0x1a,0x15,0x0b}, {0x19,0x14,0x0a}, {0x18,0x13,0x0a},
    {0x17,0x12,0x0a}, {0x16,0x12,0x0a}, {0x15,0x11,0x0a}, {0x13,0x10,0x0a},
    {0x11,0x0e,0x09}, {0x0f,0x0d,0x08}, {0x0d,0x0b,0x08}, {0x0b,0x09,0x07},
    {0x0a,0x08,0x07}, {0x09,0x07,0x07}, {0x08,0x07,0x07}, {0x06,0x06,0x06},
    {0x22,0x2f,0x1d}, {0x1d,0x2b,0x18}, {0x18,0x27,0x13}, {0x14,0x24,0x0f},
    {0x11,0x20,0x0b}, {0x0d,0x1d,0x08}, {0x0a,0x19,0x05}, {0x08,0x16,0x03},
    {0x3f,0x3f,0x1c}, {0x3f,0x3d,0x1b}, {0x3f,0x3a,0x1a}, {0x3f,0x38,0x19},
    {0x3f,0x36,0x18}, {0x3f,0x34,0x18}, {0x3f,0x30,0x16}, {0x3d,0x2d,0x14},
    {0x3b,0x2b,0x12}, {0x39,0x25,0x0c}, {0x35,0x1e,0x04}, {0x31,0x18,0x00},
    {0x2d,0x12,0x00}, {0x29,0x0e,0x00}, {0x26,0x0a,0x00}, {0x22,0x06,0x00},
    {0x2c,0x2c,0x3f}, {0x25,0x25,0x39}, {0x1f,0x1f,0x33}, {0x1a,0x1a,0x2d},
    {0x15,0x15,0x27}, {0x10,0x10,0x21}, {0x0c,0x0c,0x1b}, {0x09,0x09,0x16},
    {0x3f,0x00,0x00}, {0x34,0x00,0x00}, {0x29,0x00,0x00}, {0x1f,0x00,0x00},
    {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f}, {0x3f,0x00,0x3f},
    {0x37,0x3d,0x3f}, {0x34,0x3b,0x3e}, {0x33,0x39,0x3d}, {0x30,0x37,0x3d},
    {0x2e,0x35,0x3c}, {0x2c,0x33,0x3b}, {0x2a,0x31,0x3b}, {0x28,0x2f,0x3a},
    {0x27,0x2c,0x39}, {0x25,0x2a,0x39}, {0x22,0x26,0x34}, {0x1f,0x23,0x30},
    {0x1c,0x20,0x2b}, {0x19,0x1c,0x27}, {0x16,0x19,0x22}, {0x13,0x16,0x1e},
    {0x39,0x3c,0x3f}, {0x35,0x39,0x3d}, {0x32,0x36,0x3b}, {0x2f,0x34,0x39},
    {0x2b,0x31,0x37}, {0x28,0x2f,0x35}, {0x26,0x2d,0x33}, {0x23,0x2b,0x31},
    {0x21,0x29,0x31}, {0x1e,0x28,0x2f}, {0x1c,0x27,0x2e}, {0x1a,0x25,0x2d},
    {0x18,0x24,0x2c}, {0x15,0x23,0x2b}, {0x14,0x22,0x2a}, {0x12,0x21,0x29},
    {0x3f,0x3f,0x3f}, {0x31,0x31,0x32}, {0x28,0x28,0x29}, {0x20,0x20,0x21},
    {0x18,0x18,0x19}, {0x00,0x32,0x00}, {0x3f,0x3f,0x00}, {0x3f,0x2f,0x00},
    {0x3f,0x1f,0x00}, {0x3f,0x00,0x00}, {0x2f,0x00,0x00}, {0x33,0x33,0x3f},
    {0x26,0x26,0x3f}, {0x19,0x19,0x3f}, {0x00,0x00,0x3f}, {0x3f,0x3f,0x3f}
};

Image *load(const char *input, const char *palatte, int *n)
{
    assert(sizeof(BYTE)==1 && sizeof(WORD)==2 && sizeof(LONGINT)==4);

    Image *output = NULL;
    LONGINT i = 1, imageSize = 0, d, s, k, j, x, y, w, h;
    FILE *file = NULL;
    FileHeader fileHeader;
    ImageHeader *pImageHeader = NULL;
    ImageData *imageDatas = NULL;
    BYTE *imageData = NULL;

    file = fopen(palatte, "rb");
    if(!file) perror(input);
    fread((BYTE*)defaultPalatte,3*sizeof(BYTE),256,file);
    fclose(file);

    file = fopen(input, "rb");
    if(!file) perror(input);

    fread(&fileHeader, sizeof(fileHeader), 1, file);

    if(fileHeader.check)
        perror("Check nonzero.\n");

    if(!(fileHeader.width && fileHeader.height))
        perror("Zero size.\n");

    if(!fileHeader.num)
        perror("Zero number of images.\n");

    imageDatas = (ImageData*)malloc(fileHeader.num * sizeof(ImageData));

    for(i = 0; i < fileHeader.num; i++)
        fread(&imageDatas[i].header, sizeof(ImageHeader), 1, file);

    *n = fileHeader.num;
    output = (Image*)malloc((*n) * sizeof(Image));

    for(i = 0; i < fileHeader.num; i++)
    {
        output[i].w = fileHeader.width;
        output[i].h = fileHeader.height;

        pImageHeader = &imageDatas[i].header;

        if(pImageHeader->compression == 1)
            imageSize = pImageHeader->w * pImageHeader->h;
        else
        {
            if(i == fileHeader.num - 1)
            {
                fseek(file,0L,SEEK_END);
                imageSize = ftell(file) - pImageHeader->offset;
            }
            else
                imageSize = imageDatas[i+1].header.offset - pImageHeader->offset;
        }

        fseek(file,pImageHeader->offset,SEEK_SET);
        allocImageData(&imageDatas[i]);
        imageData = (BYTE*)malloc(imageSize * sizeof(BYTE));
        fread(imageData,sizeof(BYTE),imageSize,file);
        if(pImageHeader->compression == 1)
            decompress1(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
        if(pImageHeader->compression == 2)
            decompress2(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);
        if(pImageHeader->compression == 3)
            decompress3(imageDatas[i].data,imageData,pImageHeader->w,pImageHeader->h);

        output[i].data = (BYTE*)malloc(output[i].w * output[i].h * 4);
        x = imageDatas[i].header.x;
        y = imageDatas[i].header.y;
        w = imageDatas[i].header.w;
        h = imageDatas[i].header.h;
        for(k = 0; k < h; k++)
        {
            for(j = 0; j < w; j++)
            {
                s = k * w + j;
                d = ((k + y) * output[i].w + x + j) * 4;
                output[i].data[d]   = defaultPalatte[imageDatas[i].data[s]][0]*4+3;
                output[i].data[d+1] = defaultPalatte[imageDatas[i].data[s]][1]*4+3;
                output[i].data[d+2] = defaultPalatte[imageDatas[i].data[s]][2]*4+3;
                if(imageDatas[i].data[s]) output[i].data[d+3] = 255;
            }
        }
        free(imageData);
    }

    for(i = 0; i < *n; i++)
        freeImageData(&imageDatas[i]);
    free(imageDatas);
    fclose(file);

    return output;
}

static PyObject *
shpload(PyObject *self, PyObject *args)
{
    const char *input, *pal;
    int n, i;
    Image *output;
    PyObject *pyList = NULL, *item = NULL;
    if(!PyArg_ParseTuple(args,"ss",&input,&pal))
        return NULL;
    output = load(input,pal,&n);
    if(n == 0) return Py_BuildValue("");
    pyList = PyList_New(n+1);
    item = PyTuple_New(2);
    PyTuple_SetItem(item,0,PyInt_FromLong(output[0].w));
    PyTuple_SetItem(item,1,PyInt_FromLong(output[0].h));
    PyList_SetItem(pyList,0,item);
    for(i = 0; i < n; i++)
    {
        item = PyByteArray_FromStringAndSize((char*)(output[i].data),
                                             output[i].w * output[i].h * 4);
        PyList_SetItem(pyList,i+1,item);
    }
    for(i = 0; i < n; i++)
        free(output[i].data);
    free(output);
    return pyList;
}

static PyMethodDef ShpMethods[] = {
    {"load",shpload,METH_VARARGS,"Load a shp file."},
    {NULL,NULL,0,NULL}
};

PyMODINIT_FUNC
initshpfile()
{
    PyObject *m;

    m = Py_InitModule("shpfile", ShpMethods);
    if (m == NULL)
        return;
}

int main(int argc, char *argv[])
{
    Py_SetProgramName(argv[0]);

    /* Initialize the Python interpreter.  Required. */
    Py_Initialize();

    /* Add a static module */
    initshpfile();

    return 0;
}
```

## Create setup.py

Create a python script file

```python
from distutils.core import setup, Extension

module1 = Extension('shpfile',
                    sources = ['shpfile.c'])

setup (name = 'shpfile',
       version = '1.0',
       description = 'This is a package used for reading .shp file.',
       ext_modules = [module1])

```

## Build and Install

Run the script file. For convenience, I wrote a bash script file to
build and install with a single command.
```bash
#!/bin/bash

python setup.py build
if [ "$?" != "0" ]; then
    exit 1
fi
python setup.py install
```
