<html>
<head>
<title>Computer Technology and Skills</title>

<link href="/css/website.css" type="text/css" rel="stylesheet"/>
<link href="/css/bootstrap.min.css" type="text/css" rel="stylesheet"/>

</head>

<body>

<div class="document">
<h2>Networking</h2>

<h3>Socket</h3>
The <b>Berkeley Software Distribution</b>(BSD) socket is the primary means for communication between computers.
It is the interface between network applications and network stack.
<br><br>
In python, to use socket, simply import the socket library by <pre>from socket import *</pre>
To create a socket, use the constructor with some arguments.
<pre>
sock = socket(AF_INET, SOCK_STREAM)
</pre>
Here <font face="Courier">AF_INET</font> specifies the address family IPv4.
If <font face="Courier">AF_INET6</font> is used, then the address family would be IPv6.
<br><br>
The <font face="Courier">SOCK_STREAM</font> specifies that this is a TCP socket.
As we know, communicating with TCP is like accessing a file stream.
If you want to create a UDP socket, use <font face="Courier">SOCK_DGRAM</font> instead.

<h3>Bind</h3>
After creating the socket, the next step is to bind it with a specific port on some host.
The way to do this in python is quite straightforward.
<pre>sock.bind((host,port))</pre>
Note that there is only one argument which is a tuple of two elements.
If you by mistake pass the two arguments separately, an error would occur.
<br><br>
Here, <font face="Courier">host</font> is a string while <font face="Courier">port</font> is an integer.
If the host is an empty string, the socket would be bound to the localhost.
That is, code like <pre>sock.bind(('',5000))</pre> will bind the socket to port 5000 on localhost.

<h3>Listen</h3>

If your socket is bound to a localhost port, the next thing it has to do is listening.
The only parameter needed by this method is the maximal number of connections this socket can maintain.
Usually this is set to one.
<pre>sock.listen(1)</pre>
So the socket is put into listening mode.

<h3>Accept</h3>
The socket now is listening to the port, but not really ready to connect with a remote host.
The <font face="Courier">accept</font> method will put the program into busy waiting mode.
That is, the method will not return until someone connects to this socket.
And if someone does connect to it, the socket used by him and the address of the remote host will be returned.
The <font face="Courier">accept</font> method takes no arguments, but has two return values.
<pre>conn, addr = sock.accept()</pre>
Here <font face="Courier">conn</font> is a socket, and <font face="Courier">addr</font> is a tuple of IP and port number,
or possibly other informations.
<br><br>
Now if you type these into the python command line and press enter, the program will just hang there.
Open another terminal and type <pre>telnet localhost 5000</pre> which permits the <font face="Courier">telnet</font> client to connet to port 5000, which the socket is listening to, the accept method will return.
<br><br>
Or, you can create another client socket, also by python, to connet to your listening socket.

<h3>Connect</h3>
The creation of the another socket is just the same.
A client socket does not need the bind process. It just connects.
<br><br>
Open another terminal and open python.
<pre>
from socket import *
sock = socket(AF_INET, SOCK_STREAM)
sock.connect(('127.0.0.1', 5000))
</pre>
Then you will find in the original terminal that the <font face="Courier">accept</font> function returns.
So the connection is successfully created.
<br><br>
Note that the <font face="Courier">conn</font> socket is created automatically by the system used for nothing other than communicating with the current remote client.

<h3>Send &amp; Receive</h3>

Now both the <font face="Courier">conn</font> socket and the <font face="Courier">sock</font> socket in the client side
can use the <font face="Courier">send</font> and <font face="Courier">recv</font> methods to communicate with each other.
Note that the <font face="Courier">sock</font> socket of the server side is of no use in this process.
Don't use that socket by mistake.
<pre>
sock.send("Message")
conn.recv(1000)
</pre>
<br><br>
The <font face="Courier">send</font> method takes a string as argument, which is exactly the message sent to the other side.
While the <font face="Courier">recv</font> method takes an integer as argument,
which is the number of bytes the receiver hopes to receive, and returns a string.
The string may not be the same length as the argument specifies.
It can be shorter if the sender did not send that much information.
But it will not be greater than the specified number.
<br><br>
Now you may wonder, how is the communication synchronized?
Well, it is not synchronized.
The truth is, each side of the communication holds a buffer,
and the <font face="Courier">send</font> method of the other side simply put the information into the buffer.
But if the receiver never calls the <font face="Courier">recv</font> method, the information will just stay in the buffer.
<br><br>
Now, clear? The process is just like communicating with mails.
Each side can write to the other at any time, and the letters will be put into the mailbox of the receiver.
But it is the receiver's business to check the mailbox, which is exactly what the <font face="Courier">recv</font> method does.
If the sender sends two strings in between of which the receiver did not call the receive method,
then the next time the receiver calls the method, he will get a single string which is the concatenation of the two strings.
This means the bytes from the sender just pile in the buffer of the receiver.
<br><br>
Here are some problems.
<ul>
<li> What if the buffer is empty when <font face="Courier">recv</font> method is called?
<br><br>
Well, the program will just hang there until the sender sends some message, even a single character would cause the <font face="Courier">recv</font> method to return.
Though it is not likely to happen in real life that when the receiver checked the mailbox and found nothing in it,
he had to stay beside the box and wait, cannot even writing to tell the other side to hurry.
This is why usually a real world communication application actually maintains two threads each containing a socket,
one doing nothing but receiving message, another just sending messages.
<br><br>
Note that if there is one byte in the buffer, and the receiver calls <font face="Courier">recv</font> with argument 2,
the program will not hang there waiting for the other bytes, but just return a string that is not as long as expected.
But if the receiver calls the receive method twice with argument 1, he would have to hang there and wait for another byte.
<li>
Is there any limitation on the size of the buffer?
<br><br>
The answer is yes. You can try to send <font face="Courier">"Message"*1000000</font> to the other.
Then you will find the program hanging there, waiting for the buffer to be emptied.
Well, it does not have to be emptied, just needs to have enough room for the message.
And once the long message is fully transmitted into the buffer, the method will return.
</li>
</li>
</ul>

<h3>Close</h3>
Do not forget to close the sockets by invoking the <font face="Courier">close</font> methods.
This will free the resources occupied by the sockets.
For the listening socket, if you forget the close it, the port it is bound with cannot be used again.

</div>
</body>

</html>
