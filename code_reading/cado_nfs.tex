\documentclass[a4paper]{article}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{listings}
\usepackage{tikz}
\usepackage{color}
\usepackage{amsmath,amsfonts,amssymb,bm}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily\scriptsize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=false,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=flexible,
  keywordstyle=\color{blue},       % keyword style
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\DefineShortVerb{\#}

\title{Cado-nfs Manual}
\author{Yuncong Zhang}

\begin{document}

\maketitle

\section{Introduction}

#CADO-NFS# is an implementation of the General Number Field Sieve algorithm, which is developed for factoring large integers.
Currently only linux OS is supported.
Download the latest package from \url{http://cado-nfs.gforge.inria.fr/}, decompress into any directory you like.
To compile, simply enter the #cado-nfs# directory and execute #make#.

This system consists of modules written in C++ and python scripts organizing the modules together.
Each module is a standalone executable program.
You can directly invoke the modules specifying all the command line parameters by yourself,
or save your effort by making use of the python scripts.

For factoring relatively small integers, the script at the root directory #cado-nfs.py# should work,
using all cores on the local machine.
\begin{verbatim}
$ ./cado-nfs.py \
90377629292003121684002147101760858109247336549001090677693
\end{verbatim}

For a larger factorization distributed on several machines,
save the parameters in a file #parameterfile# and execute
\begin{verbatim}
$ ./cado-nfs.py parameterfile
\end{verbatim}
It is possible to specify parameters on the command line after #parameterfile#.
Example parameter files are given in #scripts/cadofactor/# and #parameters/factor/#.

When #cado-nfs# is running, a server is started on the local machine.
Several clients may be started to assist the computation.
Clients can be in the local or remote machines.
Clients can be started manually from command line.
If you want to let the server automatically start clients, you need to supply a list of hostnames on which to start clients, e.g.,
\begin{verbatim}
$ ./cado-nfs.py \
90377629292003121684002147101760858109247336549001090677693 \
tasks.workdir=/tmp/c59 slaves.nrclients=2 slaves.hostnames=localhost
\end{verbatim}

\newpage

\section{Script Files}

\subsection{Dependence relation of script files}
\begin{tikzpicture}
  \filldraw[fill=green!20,draw=green!50] (-2,4.4) rectangle (11,3.6);
  \draw (-1.1,4.0) node {\color{green}#/cado-nfs#};
  \filldraw[fill=blue!20,draw=blue!50] (-2,3.5) rectangle (11,-0.5);
  \draw (0.6,2.0) node {\color{blue}#/cado-nfs/scripts/cadofactor#};
  \node at(6.0,2.0) (cadoprograms){#cadoprograms.py#};
  \node at(6.0,1.0) (cadoparams){#cadoparams.py#};
  \node at(6.0,4.0) (cado-nfs){#cado-nfs.py#};
  \node at(6.0,0.0) (wudb){#wudb.py#};
  \node at(0.0,0.0) (wuserver){#wuserver.py#};
  \node at(3.0,0.0) (workunit){#workunit.py#};
  \node at(6.0,3.0) (cadocommand){#cadocommand.py#};
  \node at(3.0,3.0) (toplevel){#toplevel.py#};
  \node at(9.0,2.0) (cadologger){#cadologger.py#};
  \node at(3.0,1.0) (cadotask){#cadotask.py#};
  \path[->] (cado-nfs) edge (toplevel);
  \path[->] (cado-nfs) edge (toplevel);
  \path[->] (cado-nfs) edge (cadocommand);
  \path[->] (cado-nfs) edge (cadologger);
  \path[->] (cadotask) edge (cadoprograms);
  \path[->] (cadotask) edge (cadoparams);
  \path[->] (cadotask) edge (wudb);
  \path[->] (cadotask) edge (wuserver);
  \path[->] (cadotask) edge (workunit);
  \path[->] (cadocommand) edge (cadologger);
  \path[<->] (cadocommand) edge (cadoprograms);
  \path[->] (cadoparams) edge (cadologger);
  \path[->] (cadoprograms) edge (cadologger);
  \path[->] (cadoprograms) edge (cadoparams);
  \path[->] (wudb) edge (cadologger);
  \path[->] (wudb) edge (workunit);
  \path[->] (wuserver) edge (workunit);
\end{tikzpicture}

\subsection{Dependence relation of classes}
\begin{tikzpicture}
  \filldraw[fill=green!20,draw=green!50]  ( 0.0,22.3) rectangle ( 4.0,21.7);
  \draw ( 0.0,21.7) node {\color{green}#toplevel.py#};
  \filldraw[fill=blue!20,draw=blue!50]    (-1.2,21.3) rectangle ( 3.2,19.7);
  \draw ( 0.0,21.0) node {\color{blue}#cadocommand.py#};
  \filldraw[fill=yellow!20,draw=yellow!50]( 3.8,22.3) rectangle (13.6,16.2);
  \draw (11.6,22.0) node {\color{yellow}#cadoprograms.py#};
  \filldraw[fill=gray!20,draw=gray!50]    (-2.0,19.8) rectangle ( 3.8,17.8);
  \draw (-0.5,18.1) node {\color{gray}#cadologger.py#};
  \filldraw[fill=red!20,draw=red!50]      (-1.2,17.8) rectangle ( 1.5,16.7);
  \draw ( 1.5,16.7) node {\color{red}#cadoparams.py#};
  \filldraw[fill=orange!20,draw=orange!50](-2.0,16.2) rectangle (14.6, 9.2);
  \draw ( 0.0,16.0) node {\color{orange}#cadotasks.py#};
  \draw   ( 3.8,19.2) rectangle (13.6,16.2);
  \draw   ( 1.0, 9.2) rectangle (12.2,11.3);
  \node at( 2.0,22.0) (Cado_NFS_toplevel){#Cado_NFS_toplevel#};
  \node at( 2.0,21.0) (Command){#Command#};
  \node at( 0.0,20.0) (RemoteCommand){#RemoteCommand#};
  \node at( 2.5,20.0) (SendFile){#SendFile#};
  \node at( 0.0,17.5) (Parameters){#Parameters#};
  \node at( 0.0,17.0) (UseParameters){#UseParameters#};
  \node at( 1.0,18.0) (ANSI){#ANSI#};
  \node at( 2.5,18.0) (MyLogger){#MyLogger#};
  \node at(-0.4,19.5) (ScreenFormatter){#ScreenFormatter#};
  \node at( 2.5,19.5) (ScreenHandler){#ScreenHandler#};
  \node at(-0.2,19.0) (FileFormatter){#FileFormatter#};
  \node at( 2.5,19.0) (FileHandler){#FileHanlder#};
  \node at(-0.3,18.5) (CmdFileFormatter){#CmdFileFormatter#};
  \node at( 2.5,18.5) (CmdFileHandler){#CmdFileHandler#};
  \node at( 5.0,22.0) (InspectType){#InspectType#};
  \node at( 8.0,22.0) (Option){#Option#};
  \node at( 8.0,21.0) (PositionalParameter){#PositionalParameter#};
  \node at( 5.0,21.0) (Parameter){#Parameter#};
  \node at(11.0,21.0) (ParameterEq){#ParameterEq#};
  \node at(13.0,21.0) (Toggle){#Toggle#};
  \node at( 8.0,20.5) (Sha1Cache){#Sha1Cache#};
  \node at( 8.0,20.0) (Program){#Program#};
  \node at( 8.0,18.8) (programs) {};
  \node at( 5.0,19.0) (Polyselect){#Polyselect#};
  \node at( 7.5,19.0) (PolyselectRopt){#PolyselectRopt#};
  \node at(10.5,19.0) (PolyselectGFpn){#PolyselectGFpn#};
  \node at( 5.0,18.5) (FreeRel){#FreeRel#};
  \node at( 6.5,18.5) (Las){#Las#};
  \node at( 8.0,18.5) (Duplicates1){#Duplicates1#};
  \node at(10.5,18.5) (Duplicates2){#Duplicates2#};
  \node at( 5.0,18.0) (Purge){#Purge#};
  \node at( 6.5,18.0) (Merge){#Merge#};
  \node at( 8.0,18.0) (MergeDLP){#MergeDLP#};
  \node at( 9.5,18.0) (Replay){#Replay#};
  \node at(11.5,18.0) (ReplayDLP){#ReplayDLP#};
  \node at( 5.0,17.5) (MagmaLinalg){#MagmaLinalg#};
  \node at( 7.0,17.5) (BWC){#BWC#};
  \node at( 7.7,17.5) (SM){#SM#};
  \node at( 9.7,17.5) (ReconstructLog){#ReconstructLog#};
  \node at(12.2,17.5) (GaliosFilter){#GaliosFilter#};
  \node at( 5.0,17.0) (Sqrt){#Sqrt#};
  \node at( 7.0,17.0) (CadoNFSClient){#CadoNFSClient#};
  \node at( 9.0,17.0) (SSH){#SSH#};
  \node at(10.0,17.0) (RSync){#RSync#};
  \node at(11.0,17.0) (Ls){#Ls#};
  \node at(12.0,17.0) (Kill){#Kill#};
  \node at( 5.2,16.5) (MagmaNmbrthry){#MagmaNmbrthry#};
  \node at( 7.2,16.5) (Descent){#Descent#};
  \node at( 9.0,16.5) (Characters){#Characters#};
  \node at(11.0,16.5) (MakeFB){#MakeFB#};
  \node at( 3.0,16.0) (Polynomial){#Polynomial#};
  \node at( 5.2,16.0) (Polynomials){#Polynomials#};
  \node at( 7.2,16.0) (FilePath){#FilePath#};
  \node at( 9.0,16.0) (WorkDir){#WorkDir#};
  \node at(11.0,16.0) (Statistics){#Statistics#};
  \node at( 9.0,15.5) (HasName){#HasName#};
  \node at( 3.0,15.5) (HasTitle){#HasTitle#};
  \node at( 1.0,15.0) (Runnable){#Runnable#};
  \node at(12.0,15.5) (MakesTablenames){#MakesTablenames#};
  \node at(10.0,14.8) (HasState){#HasState#};
  \node at( 3.0,14.8) (DoesLogging){#DoesLogging#};
  \node at( 6.5,15.5) (BaseStatistics){#BaseStatistics#};
  \node at( 6.5,14.8) (SimpleStatistics){#SimpleStatistics#};
  \node at(13.0,14.0) (FilesCreator){#FilesCreator#};
  \node at( 0.0,14.0) (DoesImport){#DoesImport#};
  \node at(10.3,14.0) (HasStatistics){#HasStatistics#};
  \node at( 4.6,14.0) (Task){#Task#};
  \node at( 7.1,14.0) (ClientServerTask){#ClientServerTask#};
  \node at( 2.7,14.0) (StartServerTask){#StartServerTask#};
  \node at( 0.0,12.0) (SievingTask){#SievingTask#};
  \node at( 7.2,12.0) (Polysel1Task){#Polysel1Task#};
  \node at( 7.2,11.5) (Polysel2Task){#Polysel2Task#};
  \node at( 2.5,12.0) (PolyselGFpn){#PolyselGFpn#};
  \node at(13.0,12.0) (Duplicates1Task){#Duplicates1Task#};
  \node at(13.0,11.5) (Duplicates2Task){#Duplicates2Task#};
  \node at(10.0,12.0) (LinAlgTask){#LinAlgTask#};
  \node at( 6.0,11.2) (tasks){};
  \node at( 2.5,11.0) (FactorBaseTask){#FactorBaseTask#};
  \node at( 2.5,10.5) (FreeRelTask){#FreeRelTask#};
  \node at( 2.5,10.0) (PurgeTask){#PurgeTask#};
  \node at( 2.5, 9.5) (FilterGaliosTask){#FilterGaliosTask#};
  \node at( 5.0,11.0) (MergeDLPTask){#MergeDLPTask#};
  \node at( 5.0,10.5) (MergeTask){#MergeTask#};
  \node at( 5.0,10.0) (NmbrthryTask){#NmbrthryTask#};
  \node at( 6.0, 9.5) (LinAlgDLPTask_Magma){#LinAlgDLPTask_Magma#};
  \node at( 8.0,11.0) (LinAlgDLPTask){#LinAlgDLPTask#};
  \node at( 7.5,10.5) (CharactersTask){#CharactersTask#};
  \node at( 7.5,10.0) (SqrtTask){#SqrtTask#};
  \node at(10.0,11.0) (SMTask){#SMTask#};
  \node at( 9.5,10.0) (DescentTask){#DescentTask#};
  \node at(10.0, 9.5) (ReconstructionTask){#ReconstructionTask#};
  \node at(10.7,10.5) (StartClientsTask){#StartClientsTask#};
  \node at(-0.5,11.0) (Message){#Message#};
  \node at(-0.5,10.2) (Notification){#Notification#};
  \node at(-0.7, 9.5) (Request){#Request#};
  \node at(-0.1,15.5) (CompleteFactorization){#CompleteFactorization#};
  \path[->] (Command) edge (RemoteCommand);
  \path[->] (Command) edge (SendFile);
  \path[->] (Option) edge (PositionalParameter);
  \path[->] (Option) edge (Parameter);
  \path[->] (Option) edge (ParameterEq);
  \path[->] (Option) edge (Toggle);
  \path[->] (Program) edge (programs);
  \path[->] (HasName) edge (MakesTablenames);
  \path[->] (HasTitle) edge (DoesLogging);
  \path[->] (MakesTablenames) edge (HasState);
  \path[->] (MakesTablenames) edge (FilesCreator);
  \path[->] (BaseStatistics) edge (HasStatistics);
  \path[->] (HasState) edge (HasStatistics);
  \path[->] (DoesLogging) edge (HasStatistics);
  \path[->] (BaseStatistics) edge (SimpleStatistics);
  \path[->] (HasState) edge (SimpleStatistics);
  \path[->] (DoesLogging) edge (SimpleStatistics);
  \path[->] (DoesLogging) edge (DoesImport);
  \path[->] (Runnable) edge (DoesImport);
  \path[->] (UseParameters) edge (DoesImport);
  \path[->] (HasState) edge (Task);
  \path[->] (DoesLogging) edge (Task);
  \path[->] (DoesLogging) edge (StartServerTask);
  \path[->] (HasState) edge (StartServerTask);
  \path[->] (SimpleStatistics) edge (Task);
  \path[->] (Task) edge (ClientServerTask);
  \path[->] (ClientServerTask) edge (Polysel1Task);
  \path[->] (DoesImport) edge (Polysel1Task);
  \path[->] (HasStatistics) edge (Polysel1Task);
  \path[->] (DoesImport) edge (PolyselGFpn);
  \path[->] (Task) edge (PolyselGFpn);
  \path[->] (Task) edge (tasks);
  \path[->] (ClientServerTask) edge (SievingTask);
  \path[->] (DoesImport) edge (SievingTask);
  \path[->] (FilesCreator) edge (SievingTask);
  \path[->] (HasStatistics) edge (SievingTask);
  \path[->] (Task) edge (Duplicates1Task);
  \path[->] (FilesCreator) edge (Duplicates1Task);
  \path[->] (HasStatistics) edge (Duplicates1Task);
  \path[->] (Task) edge (LinAlgTask);
  \path[->] (HasStatistics) edge (LinAlgTask);
  \path[->] (Message) edge (Notification);
  \path[->] (Message) edge (Request);
  \path[->] (HasState) edge (CompleteFactorization);
  \path[->] (DoesLogging) edge (CompleteFactorization);
  \path[->] (UseParameters) edge (CompleteFactorization);
\end{tikzpicture}
\begin{tikzpicture}
  \filldraw[fill=green!20,draw=green!50](-2.0,-0.5) rectangle (14.0, 2.0);
  \draw ( 0.0, 1.8) node {\color{green}#wudb.py#};
  \node at( 0.0, 0.0) (WuStatusBase){#WuStatusBase#};
  \node at( 3.0, 0.0) (WuStatusClass){#WuStatusClass#};
  \node at( 6.0, 0.0) (MyCursor){#MyCursor#};
  \node at( 9.0, 0.0) (WuTable){#WuTable#};
  \node at(12.0, 0.0) (DbTable){#DbTable#};
  \node at(12.0, 0.5) (FilesTable){#FilesTable#};
  \node at( 0.0, 0.5) (DictDbAccess){#DictDbAccess#};
  \node at( 3.0, 0.5) (Mapper){#Mapper#};
  \node at( 6.0, 0.5) (WuAccess){#WuAccess#};
  \node at(12.0, 1.0) (WuResultMessage){#WuResultMessage#};
  \node at( 9.0, 0.5) (DictDbTable){#DictDbTable#};
  \node at( 9.0, 1.0) (ResultInfo){#ResultInfo#};
  \node at( 0.0, 1.0) (DbListener){#DbListener#};
  \node at( 3.0, 1.0) (IdMap){#IdMap#};
  \node at( 6.0, 1.0) (DbAccess){#DbAccess#};
  \node at( 9.0, 1.5) (HasDbConnection){#HasDbConnection#};
  \node at(12.0, 1.5) (DbRequest){#Request#};
  \node at( 3.0, 1.5) (DbWorker){#DbWorker#};
  \node at( 6.0, 1.5) (UseWorkunitDb){#UseWorkunitDb#};
  \node at( 0.0, 1.5) (DbThreadPool){#DbThreadPool#};
  \path[->] (WuStatusBase) edge (WuStatusClass);
  \path[->] (DbTable) edge (WuTable);
  \path[->] (DbTable) edge (FilesTable);
  \path[->] (DbTable) edge (DictDbTable);
  \path[->] (WuResultMessage) edge (ResultInfo);
  \path[->] (DbAccess) edge (HasDbConnection);
  \path[->] (HasDbConnection) edge (UseWorkunitDb);
  \path[->] (DbAccess) edge (DbWorker);
\end{tikzpicture}
\begin{tikzpicture}
  \filldraw[fill=blue!20,draw=blue!50](-2.0, 0.5) rectangle (14.0, 2.0);
  \draw ( 0.0, 1.8) node {\color{blue}#wuserver.py#};
  \filldraw[fill=red!20,draw=red!50]( 4.0,-0.5) rectangle ( 6.0, 0.5);
  \draw ( 5.0, 0.3) node {\color{red}#workunit.py#};
  \node at( 0.0, 1.0) (FixedHTTPServer){#FixedHTTPServer#};
  \node at( 3.5, 1.0) (ThreadedHTTPServer){#ThreadedHTTPServer#};
  \node at( 7.0, 1.0) (FixedSSLSocket){#FixedSSLSocket#};
  \node at(10.5, 1.0) (HtmlGen){#HtmlGen#};
  \node at( 0.0, 1.5) (ThreadedHTTPSServer){#ThreadedHTTPSServer#};
  \node at( 3.5, 1.5) (HTTPSServer){#HTTPSServer#};
  \node at( 7.0, 1.5) (MyHandler){#Myhandler#};
  \node at(10.5, 1.5) (ServerLauncher){#ServerLauncher#};
  \node at( 5.0, 0.0) (Workunit){#Workunit#};
  \path[->] (FixedHTTPServer) edge (ThreadedHTTPServer);
  \path[->] (FixedHTTPServer) edge (HTTPSServer);
  \path[->] (HTTPSServer) edge (ThreadedHTTPSServer);
\end{tikzpicture}

\subsection{cado-nfs.py}

This script is at the top level.
It checks and sets the environment based on the given command line parameters.
No class is defined in this script.

In this script, the following two lines:
\begin{lstlisting}[language=python]
factorjob = cadotask.CompleteFactorization(db=wudb_file,
                                           parameters = parameters,
                                           path_prefix = [])
factors = factorjob.run()
\end{lstlisting}
are the core of this script.
Here #CompleteFactorization# is a class in module #cadotask#.

\subsection{cadotasks.py}

This script file defines several base task classes like #DoesLoggin#,
#DoesImport#, #HasTitle#, etc, whose characteristics are obvious from the name.
Then a lot of task classes doing real works are defined based on these base classes.
Call them working task classes.
#CompleteFactorization# is one among them.
This class will make use of all the other working task classes.

In the #__init__# function, the task #CompleteFactorization# will create a server.
Some clients might be created to assist the server.

The following code create the clients:

\begin{lstlisting}[language=python]
for (path, key) in self.parameters.get_parameters().find(['slaves'], 'hostnames'):
    self.clients.append(StartClientsTask(mediator=self,
                                         db=db,
                                         parameters=self.parameters,
                                         path_prefix=path))
    hostnames = self.clients[-1].get_hosts_to_launch()
    whitelist |= set(hostnames)
\end{lstlisting}

Then the other tasks are created with code like:
\begin{lstlisting}[language=python]
self.fb = FactorBaseTask(mediator=self,
                         db=db,
                         parameters=self.parameters,
                         path_prefix=sievepath)
\end{lstlisting}

Then in the #run# function of #CompleteFactorization#,
the code
\begin{lstlisting}[language=python]
self.servertask.run()
\end{lstlisting}
starts the server.
Then
\begin{lstlisting}[language=python]
self.start_all_clients()

while last_status:
    last_status, last_task = self.run_next_task()
\end{lstlisting}
launches all the clients, then starts a busy loop waiting for the status to change.
This loop is the core of the entire program.

Following is the code of #run_next_task# function
\begin{lstlisting}[language=python]
    def run_next_task(self):
        for task in self.tasks:
            if task in self.tasks_that_want_to_run:
                self.tasks_that_want_to_run.remove(task)
                return [task.run(), task.title]
        return [False, None]
\end{lstlisting}

So the #task.run()# is where all the calculation is doing.
Take a look at the #run()# method of #Polysel1Task# for example.
First are a lot of checking for whether there are already polynomials imported.
If so, skip the polynomial phase directly.
After that, when there is no polynomial imported, the following code
\begin{lstlisting}[language=python]
while self.need_more_wus():
    self.submit_one_wu()
while self.get_number_outstanding_wus() > 0:
    self.wait()
\end{lstlisting}
launches several #WorkUnits# and wait for them to finish the task.

While the #run()# in #MakeFB# has the following code
\begin{lstlisting}[language=python]
p = cadoprograms.MakeFB(out=str(outputfilename0),
                    side=0,
                    lim=self.params["rlim"],
                    stdout=str(stdoutpath),
                    stderr=str(stderrpath),
                    **self.merged_args[0])
message = self.submit_command(p, "", log_errors=True)
if message.get_exitcode(0) != 0:
    raise Exception("Program failed")
\end{lstlisting}
in fact, most of the tasks start running the program in this format.
Let's first look at the #submit_one_wu()# function, then we find
\begin{lstlisting}[language=python]
p = cadoprograms.Polyselect(admin=adstart, admax=adend,
                            stdout=str(outputfile),
                            **self.progparams[0])
\end{lstlisting}

So basically, it is the classes in #cadoprograms.py# doing the work.
We first look at the function #submit_command#.
Here is a sample of the function body
\begin{lstlisting}[language=python]
process = cadocommand.Command(command)
(rc, stdout, stderr) = process.wait()
\end{lstlisting}

So the #Command# class in the #cadocommand# module is handling the computation processes.

\subsection{cadocommand.py}

In the #__init__()# method of #Command#, the following code
\begin{lstlisting}[language=python]
progargs = self.program.make_command_array()
self.child = subprocess.Popen(progargs, *args, stdin=self.stdin,
    stdout=self.stdout, stderr=self.stderr, **kwargs)
\end{lstlisting}
creates the subprocess and put it in the #self.child# attribute.
Then in the #wait()# method
\begin{lstlisting}[language=python]
(stdout, stderr) = self.child.communicate()
\end{lstlisting}
actually executes the program.

To understand what the process is doing,
all we need is to have a look at the #make_command_array()# method of #Program#.

\subsection{cadoprograms.py}

The class inheritance structure is much simpler in this module.
The base class is #Program# and all other programs are directly inherited from it.

The #Program# base class is oblivious to how programs get input data,
or how they provide output data.
It does, however, handle redirecting #stdin/stdout/stderr# from/to files and accepts file names to/from which to redirect.
This is done so that #workunits# can be generated from Program instances;
in the #workunit# text, shell redirection syntax needs to be used to connect stdio to files,
so a #Program# instance needs to be aware of which file names should be used for stdio redirection.



\section{Parameters}

\section{Module One: Polyselect}

There are three standalone executable programs (i.e. has #main# function) in this module,
#polyselect# and #polyselect_ropt#, and the corresponding source files are #polyselect.c# and #ropt_main.c#,
respectively.

The #polyselect# program generates raw polynomials using Kleinjung's method and then apply size optimization.
The polynomial file format is as follows:
\begin{itemize}
  \item Each line is either empty, comment, or key value pair;
  \item Comment line is started by \verb=#=.
  \item A key value pair is in the form of #key: value#.
  \item Each polynomial is defined by a list of key value pairs starting by #n#, the to-be-factored integer.
	Then #Y1# and #Y0#, defining $g(x)=Y_1x^2+Y_0$.
	Then comes #c4,c3,\ldots,c0#, defining $f(x)=c_4x^4+c_3x^3+c_2x^2+c_1x+c_0$.
	For different degrees the indices may vary.
\end{itemize}
For each polynomial, the program puts the original raw polynomial in comments,
followed by the optimized polynomial. Like the following
\begin{verbatim}
# Raw polynomial:
# n: 353493749731236273014678071260920590602836471854359
705356610427214806564110716801866803409
# Y1: 34554385164289
# Y0: -8761140985868994725906
# c4: 60
# c3: -44
# c2: -122597099987059
# c1: 3642475004612919403345
# c0: 217805892978013836619
# raw lognorm 33.24, skew 2550784.00, alpha -0.19 (proj: -1.44),
E 33.05, exp_E 29.54, 2 rroots
# Size-optimized polynomial:
n: 353493749731236273014678071260920590602836471854359705
356610427214806564110716801866803409
Y1: 34554385164289
Y0: -8762878725898906819716
c4: 720
c3: -144835728
c2: -1287467551051903
c1: 34070214440641525820
c0: 39845338409921085803795148
# lognorm 32.40, skew 484992.00, alpha -0.68 (proj: -1.73), E 31.71,
exp_E 29.40, 4 rroots
\end{verbatim}

\subsection{polyselect.c}

At the beginning of the #main()# function the command line parameters are processed.
The Kleinjung's method takes parameters
\begin{itemize}
  \item $\bm{d}$: degree of the polynomial
  \item $\bm{N}$: large integer $N$ to be factored
  \item $\bm{a_{d_{\min}}},\bm{a_{d_{\max}}}$: Range of the leading coefficient
\end{itemize}

It then generates a large number of polynomials of degree $d$ and leading coefficients lying in $[a_{d_{\min}},a_{d_{\max}}]$.
The corresponding command line arguments are #-degree,-admin,-admax# respectively.
There is also an argument #-incr# specifying distance between two adjacent choices of $a_d$'s.

It is required that the degree one coefficient of $g(x)$ has two prime factors in $[P,2P]$ where $P$ is an integer,
and is provided by the command line option #-P#.

When all the arguments are set, the program start threads by system call #pthread_create()#,
which executes a procedure and returns a success code.
Here the procedure is function #void * one_thread(void* args)#.
\begin{lstlisting}[language=Java]
int i;
for (i = 0; i < nthreads; i++)
    pthread_create (tid[i], NULL, one_thread, (void *) (T+i));
for (i = 0; i < nthreads; i++)
    pthread_join (tid[i], NULL);
\end{lstlisting}
The parameter #args# are specified as an argument to #pthread_create()#
and then parsed automatically by #pthread_create()# to #one_thread()#.

The system call #pthread_join# are then invoked to wait for the threads to terminate.

Following is the definition of #one_thread()#.
\begin{lstlisting}[language=Java]
void*
one_thread (void* args)
{
    tab_t *tab = (tab_t*) args;
    while (next_ad (tab[0]->ad, tab[0]->thread))
        newAlgo (tab[0]->N, tab[0]->d, tab[0]->ad);
    return NULL;
}
\end{lstlisting}
where #next_ad# find if there is new $a_d$.
If not, return 0, else, put the next $a_d$ into #tab[0]->ad#.
For each $a_d$, the function #newAlgo()# is called.
\begin{lstlisting}[language=Java]
static void
newAlgo (mpz_t N, unsigned long d, mpz_t ad)
{
    unsigned long c = 0;
    header_t header;
    proots_t R;

    header_init (header, N, d, ad);
    proots_init (R, lenPrimes);

    if (sizeof (unsigned long int) == 8) {
        c = collision_on_p (header, R);
        if (nq > 0)
            collision_on_sq (header, R, c);
    }
    else {
        c = gmp_collision_on_p (header, R);
        if (nq > 0)
            gmp_collision_on_sq (header, R, c);
    }

    proots_clear (R, lenPrimes);
    header_clear (header);
}
\end{lstlisting}

If we keep diving in and in, we will finally find the #match()# or #gmp_match()# function
which generates a single polynomial and size-optimize it.
And both of the two functions call the same #optimize_raw_poly()# function for the size optimization.
This is defined in the file #size_optimization.c#.

\subsection{size\_optimization.c}

The core function in this file is #size_optimization_aux()#.
This function takes #f_opt,g_opt# of type #mpz_poly_ptr# to output optimized polynomials,
#f_raw,g_raw# of type #mpz_poly_srcptr# as input polynomial.
The return value is the skew log-norm of optimized $f(x)$.

There are other parameters configuring the process of optimization.
The #unsigned int sopt_effort# enable or disable the rotation process.
#sopt_effort=0# means that only translation is considered.
The #int max_rot# means considering translation up to this degree.

The degree of $g(x)$ is expected to be $1$.

\subsubsection{Translation}

A list of #mpz_t# integers, #list_k# is defined
\begin{lstlisting}[language=Java]
list_mpz_t list_k;
\end{lstlisting}
First, a number of translations are calculated and put into #list_k#,
using the method proposed in \textit{Better Polynomials for GNFS}.

\begin{lstlisting}[language=Java]
list_mpz_t list_k;
if (d == 6 || d == 5)
{
    sopt_find_translations_extra (list_k, f_raw, g_raw, verbose);
    if (d == 6)
        sopt_find_translations_deg6 (list_k, f_raw, g_raw, verbose);
    else if (d == 5)
        sopt_find_translations_deg5 (list_k, f_raw, g_raw, verbose);
    mpz_set_ui (tmp, 0);
    list_mpz_append (list_k, tmp);
    list_mpz_sort_and_remove_dup (list_k, verbose);
}
else
{
    mpz_set_ui (tmp, 0);
    list_mpz_append (list_k, tmp);
}
\end{lstlisting}

The function #sopt_find_translation_extra# finds translations by another method.
All found translations are gathered in the #list_k#, which is then sorted and deprived of repeated items.

For smaller degrees, i.e., $d\leq 4$, the translation is omitted.

Next, let us have a look at the function #sopt_find_translations_extra#.
\begin{lstlisting}[language=Java]
static void
sopt_find_translations_extra (list_mpz_t list_k, mpz_poly_srcptr f0,
                              mpz_poly_srcptr g, const int verbose)
{
  int d = f0->deg;
  double cd, cdm1, cdm2, cdm3, g1, g0;
  mpz_poly_t f;

  mpz_poly_init (f, d);
  mpz_poly_set (f, f0);

  int count = 0;
  while (mpz_sgn (f->coeff[d-2]) == mpz_sgn (f->coeff[d-3]) && count < 100)
    {
      mpz_t k;
      count ++;
      mpz_init (k);
      if (mpz_sgn (f->coeff[d-3]) == mpz_sgn (g->coeff[0]))
        mpz_set_si (k, -1);
      else
        mpz_set_si (k, 1);
      mpz_poly_rotation (f, f, g, k, d-3);
      mpz_clear (k);
    }

  cd = mpz_get_d (f->coeff[d]);
  cdm1 = mpz_get_d (f->coeff[d-1]);
  cdm2 = mpz_get_d (f->coeff[d-2]);
  cdm3 = mpz_get_d (f->coeff[d-3]);
  g1 = mpz_get_d (g->coeff[1]);
  g0 = mpz_get_d (g->coeff[0]);

  double_poly_t res;
  double roots[3];
  int nr;
  double_poly_init (res, 3);
  res->coeff[0] = cdm2 * g0;
  res->coeff[1] = (double) (d-1) * cdm1 * g0;
  res->coeff[2] = (double) (d*(d-1))/2 * cd * g0;
  res->coeff[1] += cdm2 * g1;
  res->coeff[2] += (double) (d-1) * cdm1 * g1;
  res->coeff[3] = (double) (d*(d-1))/2 * cd * g1;
  res->coeff[0] -= cdm3 * g1;
  res->coeff[1] -= (double) (d-2) * cdm2 * g1;
  res->coeff[2] -= (double) ((d-1)*(d-2))/2 * cdm1 * g1;
  res->coeff[3] -= (double) (d*(d-1)*(d-2))/6 * cd * g1;
  nr = double_poly_compute_all_roots_with_bound (roots, res, 1e15);
  for (int i = 0; i < nr; i++)
    {
      if (verbose)
        fprintf (stderr, "# sopt: find_translations_extra %f\n", roots[i]);
      list_mpz_append_from_rounded_double (list_k, roots[i]);
    }
  double_poly_clear (res);
  mpz_poly_clear (f);
}
\end{lstlisting}

\end{document}
