---
title: 基于Hash的一次签名算法
---

# 基于Hash的一次签名算法

从Lamport-Diffie签名开始吧。这是天下第一个完全基于Hash的签名，让人们发现做到这一点是可能的（虽然要付出很大的代价）。

不知道Lamport是怎么想出这个方案的。按照我自己的理解，可能是从怎样签一个比特开始的吧。想想啊，假如一个消息的每个比特都不能篡改，那么整个消息不就不能篡改了吗？

怎样签一个比特呢？我们设想一个这样的场景，一个将军要向部队下达命令，这个命令只有两种可能，进攻或者撤退。这就是一个比特的消息。战场上，将军只能让传令官帮他向军队传达命令，但这岂不是等于让传令官掌握了军队？为了解决这个问题，在出发前，将军在动员大会上向全军提出了两个问题A和B。这两个问题将军是知道答案的，但除了他之外其他人无论如何得不到答案，但如果他们听到答案，他们可以验证是不是对的。在战场上，将军如果要发出进攻的命令，就把A问题的答案告诉传令官，如果要撤退，就把B问题的答案说出来。传令官没有办法篡改这个命令，因为他不知道另一个问题的答案。而士兵听到某个问题的答案后也就能肯定这一定是将军发出来的命令。这就解决了传递一个比特的问题。

用密码学的术语来讲，这一对问题就是公钥，这两个问题的答案就是私钥，而某个问题的答案就是签名。这个公钥只能用一次。

那如果想给一个更长的消息签名怎么办？简单，消息有多少个比特，就生成多少对问题。当然，这些问题的顺序一定要在公钥中严格指定好，不然把消息中的某些比特换换顺序就得到了另一个消息的正确签名。

在密码学中，生成一个别人很难得到答案却很容易验证答案的问题，正是Hash的看家本领：答案就是Hash的原像，问题就是Hash值。于是Lamport签名的思想很清楚了。假如我们要签名256比特，还想要有256比特的安全性，那么我们就准备256对256比特的随机数，再计算所有512个随机数的Hash值。这256对Hash值就是公钥。签名的时候，对每一对Hash值，如果消息对应位置的比特是0，就把第一个Hash的原像放到签名里，不然就放第二个Hash的原像。当然，签完之后，这个公钥也就不能再用了。

这就是Lamport一次签名方案。显然，这个方案的公私钥对还有签名都太大了。仔细想想有没有哪些信息是浪费的？比如，我们可不可以把零比特忽略掉，而只在出现一的位置放一个Hash原像呢？这样我们就能立刻省掉一半大小的公钥，因为每个位置只需要准备一个问题，而对这一比特的签名通过放答案和不放答案来决定。显然，这个想法是有问题的——敌手不能随便把0比特修改成1，但可以随便把1比特修改成0。不过，这一缺点可以用另一种方法来弥补：因为构造的假消息中1的数量一定要比真消息中的数量少，我们只要把1比特的数量信息也给签了，附在原来的签名后面，就可以把所有假消息全部排除了。比如消息长度是256比特，那么1的数量只需要8比特就能表示。

问题又来了，这8个比特我们该怎么签呢？当然，为每个比特准备一对问题是最稳妥的方法，反正代价比起省掉的256个Hash已经非常小了。不过这样得到的方案怎么说呢，不美观——前面256个比特是一种验证方法，后面8个比特是另一种，怎么这么别扭呢？如果也和前面一样只把1对应的位置的答案放出来呢？那么敌手也能随便篡改这个数字了。不过，如果我们用这8个比特来记录0的数量，结果就不一样了：敌手只能把消息中0的数量变多而不能变少，但这意味着他一定要把后面表示0的个数的8个比特中的某个0变成1，要不然这个数字不可能增大。换句话说，敌手构造的消息，前面零的数量不能比真消息的少，后面的数字不能比真消息的大。唯一要让它们相等的办法只能是让它们等于真消息中零的数量，而只有真消息满足这一条件。

Winternitz在Lamport签名的思想上继续改进。Lamport用一个Hash签一个比特，Winternitz想能不能多签几个比特呢？比如说4个比特？为了完成这个扩展，我们把Lamport签名看做一个更高级算法的特殊形式：一个能签n个比特算法的n=1的情况。如果我们把一个随机数和它的Hash看做一个长度为2的Hash链，这条链是个有向图，从原像可以走到Hash值，从Hash值无法走回原像。把Hash值标为0，把它的原像标为1，那么，Lamport签名相当于在每个位置把那一比特对应的链上的对应标记的值放到签名里。如果把链延长一点呢？比如签4个比特，那么4个比特可以表示16个数字，把链的长度延长为16，这可以通过把随机数算15次Hash得到，原像标记15，而最后的Hash值标为0。256比特的消息可以看做64个0-15的数字，那就是64条链。如果位置零的四个比特是1001，也就是9，那么把那个位置的链上标记9的数据放到那个位置的签名上。验签的时候，只要检查是不是从这个数字做9次Hash就能得到公钥。

好，现在还是原来的问题，那就是敌手可以篡改消息。假消息的每个位置对应的数字都可以小于等于真消息。解决的方法也类似之前的思想：把所有位置的数字（用15减之后）加起来，编码放到最后，用同样的方式签名。敌手只能增大真消息的这个和，却只能减小这个和的编码。

注意到Winternitz签名是用计算代价换空间代价。极端情况下，如果把分组直接设定为256比特，理论上可以只用一个Hash来作签名，只要你有能力算2的256次方个Hash。只不过，你要是有这个算力，这个Hash也不安全了。
