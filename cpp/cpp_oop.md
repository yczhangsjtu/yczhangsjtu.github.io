---
title: C++面向对象程序设计基本概念
---

# C++面向对象程序设计基本概念

C++的面向对象程序设计的核心目标是实现对不同的类的对象进行统一的操作。为了实现这一目标，C++提供了继承和动态绑定。

## 继承

使用继承来给不同的类提供统一的接口，基本模式是声明一个基类，从基类的基础上派生出若干子类。基类中有些函数的行为只有子类才能明确，这些函数在基类中就被声明为虚函数，在前面用virtual关键词修饰。

假如要定义基类Shape，以及子类Rectangle和Circle。基类中可以实现一些不需要知道具体形状就能确定的行为，比如`getPosition()`获取一个Shape在画板上的坐标。而有些行为，比如`getArea()`获取图形面积，则必须由子类来实现，于是Shape类中就可以声明函数`virtual double getArea() const;`。

### 子类的构造函数

子类不能直接初始化基类中的成员，需要调用基类的构造函数来初始化它的基类部分。它可以在自己的初始化列表中直接使用基类的类名来调用基类的构造函数。如果不显式调用，基类会调用默认初始化函数。

虽然从语法上讲，我们可以在子类的构造函数中显式初始化基类成员，但最好不要这么做，让基类自己负责初始化，减少基类和子类的实现之间的耦合。

### 静态成员

基类如果定义了静态成员，这个静态成员在整个继承体系中都是唯一的，不管这个类定义了多少子类。

### 权限控制

派生本身有访问权限控制，可以是public或private的，这被称为派生访问说明符。这个说明符不影响子类本身对基类的成员的访问权限，只会改变子类能够访问的基类的成员对于子类用户的访问权限。比如，如果派生是public的，则基类中的public成员对子类用户仍然是public的。如果派生是private的，则基类中的public成员就成了子类的private成员。

## 动态绑定

假如基类定义了一个函数`f()`，而子类覆盖定义了这个函数。如果继承是public的，那么一个子类的对象可以出现在任何要求基类对象的地方。所以一个基类的引用或指针既有可能指向一个基类的对象，也有可能指向这个基类的某一个子类的对象。

当存在继承时，一个变量在编译器眼里的类型和运行时所指向对象的实际类型是有区别的。我们将变量声明时的类型称为静态类型，而将它指向的内存中的对象的类型称为动态类型。

当对基类的引用调用函数`f()`时，有时需要根据这个对象的动态类型判断该调用哪个版本的函数，但这个判断只能在运行时才能进行。这就叫做动态绑定。

比如基类Shape定义了一个默认的`getArea()`函数，直接返回0，子类定义了自己的`getArea()`函数。考虑下面这个函数

```c++
void printArea(const Shape &shp) { 
    cout << shp.getArea() << endl; 
}
```

因为shp的动态类型可能是Shape的任意子类的类型，编译器在编译这个函数时并不知道到底会是哪个子类，这个只有在运行时才能知道。

虚函数的声明`virtual`告诉编译器这个函数要在运行时动态绑定，否则其解析过程要在编译时确定。这种情况下，编译器根据静态类型决定该调用哪个函数，不管动态类型是什么。

### 基类到子类的类型转换

因为一个基类对象的动态类型不一定属于子类，所以不存在从基类到子类的类型转换，即使动态类型真的是这个子类也不行，因为编译器只能根据指针或引用的静态类型来判断转换是否合法。

如果一定要做这个转换，可以用`dynamic_cast`，它将在运行时动态检查转换是否合法。或者如果我们自己确定从基类转到某个子类是安全的，就用`static_cast`强行告诉编译器可以做转换。

### 子类到基类的类型转换

子类到基类的类型转换一般来说指的是基类的引用或指针可以指向子类的对象，但并不存在真正的对变量的类型转换，即不能把子类对象赋值给基类对象。这么做的时候，实际上是在调用基类的拷贝构造函数。基类的拷贝构造函数不清楚子类的派生部分，所以只会把子类对象中的基类部分拷贝过去，得到的结果是一个静态和动态类型都是基类的对象。

因此，动态绑定也只发生在对指针或引用调用虚函数的时候，直接对基类的变量调用虚函数仍然会调用基类的版本。

## 虚函数

一般来说，如果一个函数永远不会被用到，可以不定义它，也不会出现链接错误。但虚函数不行。因为编译器不知道到底会调用它的哪个版本的实现，所以要为每个虚函数都提供一个定义。

任何构造函数之外的非静态函数都可以是虚函数。如果一个函数在基类中是虚函数，在子类中也隐式地是虚函数，所以不必再用virtual修饰一次。

### override关键字

如果在子类中覆盖基类的函数时，不小心把形参列表写错了，编译器不会报错，只会以为子类重载了这个函数。这种错误非常难查出来。为了让编译器自动帮忙解决这个问题，在C++11新标准中引入了override关键字，放在函数的形参列表后。编译器会检查子类中的函数一定覆盖了基类中的一个虚函数。

### final关键字

C++11标准也引入了final关键字。一个用final修饰的类不允许被继承。一个用final修饰的虚函数不允许被覆盖。

### 虚函数的默认实参

虽然对虚函数进行调用时，调用哪个函数是由引用的动态类型决定的，但调用时使用的默认实参却由静态类型决定。所以，覆盖虚函数时最好使用完全相同的默认实参，不然可能会出现意想不到的运行结果。

### 虚析构函数

我们希望delete一个基类的指针时，程序能够根据指针所指对象的动态类型来调用析构函数。我们通过在基类中把析构函数定义为虚函数来做到这一点。

## 抽象基类

因为虚函数要求为每一个版本提供一个实现，但对于基类来说，可能某个函数的默认版本确实完全没有意义，又不得不写一些完全不会执行的代码来充当实现。

这种情况下，我们会发现，我们根本不可能用到一个完全只属于基类而不属于任何子类的对象。比如Shape基类，现实中并不存在一个对象，它只是一个“形状”，却不是任何具体的形状。

我们可以把对于基类而言完全没有意义的函数定义为纯虚函数。这样的函数无须定义。声明的方法是在声明处将该函数赋值为0。

我们不能在类的外部将函数赋值为0，即不能在类的外部定义一个函数为纯虚函数。但我们可以在外部为一个纯虚函数提供定义（虽然永远不会被用到），而且只能在外部。

含有纯虚函数的类是抽象基类。我们不能直接创建抽象基类的对象。子类可以覆盖或者不覆盖纯虚函数，如果不覆盖的话，子类也就成了一个抽象基类。换句话说，只有所有成员函数都被定义了，一个类才不再抽象，才可以创建对象。

## 多重继承

C++允许一个子类继承多个基类，这些基类在派生列表中用逗号隔开。一个子类对象包含所有基类的非静态数据成员。

初始化时，子类的构造函数将实参分别传递给每个基类，基类的构造顺序只和派生列表中基类的顺序一致，和初始化列表的顺序无关。

如果有一个重构函数，分别接受这个子类的两个基类类型的引用作为参数，则将子类对象传递给这个函数会产生二义性错误，因为编译器不会在基类的几种转换中进行比较和选择，对编译器来说转换到哪个基类都一样好。

## 虚继承

一个子类不能多次直接继承一个基类，但有可能通过间接继承多次继承一个基类。这种情况下，一个子类对象中会包含多份这个基类的数据成员。为了避免这种情况发生，C++定义了虚继承。

在一个派生项中使用virtual关键字表明这个派生是虚的。一个虚继承表示子类愿意共享这个基类的数据成员。当两个基类A和B都虚继承自同一个基类C时，子类中这A和B的数据成员就会共享C的数据成员。

如果C的一个成员被A和B同时定义了，在子类中访问这个成员时就会产生二义性。

因为虚基类的使用出现在对它的需求之前，所以一般涉及到虚基类的设计需要一次完成。

在涉及到虚基类时，构造函数会首先把所有虚基类构造完毕，然后再按照顺序构造非虚基类。