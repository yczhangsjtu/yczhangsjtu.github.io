# P2P Mixing and Unlinkable Bitcoin Transactions

所谓P2P Mixing，就是指匿名P2P通讯协议。

本文提出了一个新的P2P Mixing，叫做DiceMix，能够容忍较高比例的恶意节点存在。

本来P2P Mixing和比特币并没有什么关系，只是本文作者无意间发现DiceMix可以和比特币兼容到一起，把原本假名的比特币系统变得真匿名。

文章的贡献：

* 提出一个概念P2P Mixing，作为现有的DC-network一个Generalization
* 提出了DiceMix协议，并且进行了实现
* 提出了CoinShuffle++协议，比CoinShuffle更容易实现，而且效率更高
* 提出了对P2P Mixing协议的一种攻击，以及预防措施

## P2P Mixing Protocol

该协议的通讯模型是网络中有一个“公告板”，也就是广播服务器，所有节点把需要广播的消息发给“公告板”，然后“公告板”向全网进行广播。为了容忍“公告板”本身也被敌手控制，模型允许一个网络里可以有多个“公告板”。

该协议的目标是达到这样的效果：

1. 匿名性：所有$n$个节点同时发起广播，不借助任何第三方，使得敌手无法判断哪条消息来自哪个节点。每个诚实节点的匿名集为所有诚实节点。哪怕敌手控制了$n-2$个节点，也就是整个网络里只有两个诚实节点！
2. 可结束性：协议可以结束，不会永远运行下去。在敌手控制“公告板”的情况下满足这个性质是几乎不可能的，因此在需要可结束性时我们只能依赖更强的假设“公告板”是可以信任的。

网络中所有节点都有一个标识身份用的签名公钥。

输入消息必须有新鲜性。输出消息要被所有节点确认。

这个协议的每一次执行包含两个步骤，第一步是产生输入消息，算法为$Gen()$，这一步里有可能剔除一些可能为恶意的节点，最终得到待确认的消息集合$M$和最终的确认节点集合$P$。然后调用$Confirm(i,P,M)$子协议。如果第二个协议中又发现有恶意节点，那么$M$被丢弃，剔除恶意节点，重新从$Gen()$开始。

![p2p-mixing-execution](p2p-mixing-execution.png)

上述的$Gen()$算法和$Confirm()$子协议都是用户自定的。

匿名性仅对成功的消息满足。也就是说敌手可能获知某个失败的执行中消息是谁发出的。但在这个协议中，没有获得确认的消息仅仅是一堆随机产生的比特串而已，因此并没有影响隐私性。

## Solution Overview

构建P2P Mixing Protocol的一个重要工具就是Dining Cryptographers Network (DC-net)。这个网络的一个简单思想就是：如果P1和P2共享一个秘密$s$，他们其中一人想匿名发布消息$m$，于是P1发布$m\oplus s$，P2发布$s$。外人可以把两个消息加起来得到$m$，但却不知道消息是从他们当中哪个人发出的。这个简单的协议可以被扩展到多用户的情况。

DiceMix协议是在$n$个节点中运行$n$个DC-net。设第$i$个节点发布的消息为$x_i$，每个节点在第$j$个DC-net中发布$x_i^j$，于是第$j$个DC-net上得到的消息是$S_j=\sum_i x_i^j$。从这些值可以恢复出$x_1,\cdots,x_n$，方法是牛顿等式。令$f(x)$为一个首一多项式，使得它的$n$个根恰为$x_1,\cdots,x_n$。设$$f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0$$，其中$a_n=1$，则有牛顿等式$$S_1+a_{n-1}=0$$，$$S_2+a_{n-1}S_1+2a_{n-2}=0$$，$$S_3+a_{n-1}S_2+a_{n-2}S_1+3a_{n-3}=0$$等等。于是推出$f(x)$的各项系数，从而求出$f(x)$的根。这个根的集合即为待确认的消息集合$M$。

节点产生的$x_1,\cdots,x_n$为难以预测的随机比特串。为了防止对手破坏这个过程，在进行广播之前，每个节点先把自己的消息进行承诺。随后，进行上述过程，算出消息集合$M$。每个节点检查$M$中是否包含自己的消息。如果所有节点都在$M$找到自己的消息，则可以确认$M$的合法性，否则，一旦**所有**节点都发现自己的消息没有被包含，则所有节点公布自己在这一轮的私钥，各自运行别人的计算过程，查看是谁发的消息出了问题。恶意节点作恶的方式是公布不一致的$x_i^j$，导致求$f(x)$的根得出不一样的结果。只有$M$中恰好只包含一部分节点的消息时他才能攻击成功。但在不知道其他节点的消息的情况下，他很难使得其中部分节点的消息被包含在$M$里，攻击成功的概率忽略不计。

## The DiceMix Protocol

这个协议中需要用到：数字签名算法，非交互的密钥协商算法，哈希函数等密码学算法。

### DiceMix 对应用的接口

* DiceMix 对应用提供的保证（前提是“公告板”不是恶意的）
  * Agreement：同一轮消息传输中所有诚实节点以同样的参数运行消息确认子协议
  * Validity：没有节点有正当的原因拒绝确认消息
* DiceMix 对应用提出的要求（即使“公告板”是恶意的）
  * 输入消息编码为素数域$\mathbb{F}_p$中的元素，其中$p$大于节点数
  * 输入消息有足够大的熵，难以预测
  * 消息确认子协议的正确性
  * 消息确认子协议一旦失败，一定能找出至少一个恶意节点，并且不会冤枉诚实节点

### 协议细节

首先所有节点运行**Start-DiceMix**算法，由这个算法启动**DiceMix**协议，运行**Run()**函数。

**Run()**函数的运行分四个阶段：

* `KE`: 密钥交换
* `CM`: 产生DC-net消息并承诺
* `DC`: 公布DC-net消息
* `CF`/`SK`: 接受消息/查找恶意节点

#### Start-DiceMix

每个节点的初始化参数有其他节点的集合，所有节点的公钥$VK[]$，以及自己的私钥$sk$，和Session ID。

#### 密钥交换

每个节点本地生成一对用于密钥交换的公私钥对，$NPK$和$NSK$，用$sk$签名并公布$NPK$。接受所有其他节点的公钥并验证签名。每两个节点之间的共享密钥起到的作用就是使这两个节点产生互相抵消的混淆信息。

####  产生DC-net消息并承诺

每个节点调用$Gen()$函数（由具体应用指定）得到需要广播的消息$m$，求幂得到DC-vector，并在DC-vector上加上DC-pad进行混淆（所有节点的DC-pad加起来会消掉）。对DC-vector进行承诺，签名并广播。

混淆信息是这样的：

* 对两个编号$i>j$的节点，对DC-vector的第$s$位，节点$i$产生的针对$j$的混淆信息DC-pad$[i][j]$为$G(K_{ij},s)$，其中$G$为一个Hash函数，$K_{ij}$为两者的共享密钥，节点$j$产生的混淆信息为$-G(K_{ij},s)$。
* 每个节点（对第$s$位置上的）的混淆信息为针对其他所有节点的混淆信息加起来。
* 于是，如果把所有节点的混淆信息加起来，和一定是零。得到的结果便恰好是每个人真正的vector的和。

#### 公布DC-net消息

所有的承诺都公布之后，大家再公布各自的DC-vector。把每个人的DC-vector值加起来，抵消掉混淆信息，就得到了向量$S$，其中$S_j=\sum_i m_i^j$。利用上文所说的牛顿等式可以把所有$m_i$求出来。

每个节点进行检查，如果得到的消息集合$M$包含自己的消息$m$，就对$M$进行确认，否则公布自己的$NSK$。

如果所有节点都拒绝确认消息并公布了私钥，便根据别人的$NSK$查找恶意节点并剔除。

#### 协议变种

* 假定公告板换成一个通讯协议，且这个协议能够保证在所有消息的汇总收到之前一定不会泄露信息，那么就可以省掉承诺环节。
* 假定公告板可以承担较大运算量，它就可以进行DC轮的运算，并公布结果，且承担查找恶意节点的责任。

## 性能分析

* 通讯代价：$(c+3)+(c+1)f$轮交互，其中$f$为恶意节点数量，$c$是确认子协议需要进行的轮数。如果是下文将要介绍的Bitcoin Mixing Protocol，$c=1$，通讯代价就是$4+2f$。
* 运行时间：
  * 测试环境：协议用Python实现，签名算法由OpenSSL实现，采用曲线secp256k1上的ECDSA算法。多项式运算用的是Python的Pari-gp库。测试环境使用的是Emulab机器，在多台机器上（频率在2.2-3.0GHz）进行了测试。所有节点拥有10M带宽，和公告板都预先建立了TCP连接，公告板为1G带宽。连接延迟50ms。测试节点数量从5到50。需要混淆的数据为160比特。
  * 测试结果：总计算时间基本随节点数呈线性增长，当50个节点的时候时间为3s，其中求解方程占用时间为2s。
  * 优化：求解多项式的过程改用FLINT库实现的Kaltofen-Shoup算法进行优化，将求解方程的时间优化为0.15s。
  * 比较：即使是未优化的版本，DiceMix也比目前的混币协议高效得多。比如CoinShuffle，当节点数量为50时需要三分钟时间完成P2P Mixing，还是在假设所有节点都是诚实的基础上！如果恶意节点有10个，CoinShuffle运行一次的时间就有30分钟！

## 高效的比特币混币协议

基于DiceMix和现有的CoinShuffle协议，提出了CoinShuffle++。

在原有的P2P Mixing要求（Agreement和Validity）基础上，又提出了新的要求：Correct Balance。

这个协议需要达到这么一个效果：参与方每个人都有一笔公开输入，他们需要共同完成一笔CoinJoinTx交易，将每一笔输入中的$\beta$个BTC输出到一个新生成的混币地址中。交易完成后，大家都能在找到属于自己的混币地址的输出，但除了自己的混币地址，并不知道其他混币地址都是谁的。A

作为DiceMix的一个应用协议，CoinShuffle++只需要指定$Gen()$函数和$Confirm()$函数。

* **Gen()**函数比较简单，每个用户随机生成新的比特币公私钥对，返回公钥。
* **Confirm()**函数就是用一种确定的方式生成CoinJoinTx交易，大家都签名并公开，如果有任何人不签就把他当恶意节点剔除，重新开始协议。如果签名收集齐了就可以公开上链。

CoinJoinTx交易是标准的比特币协议，所以不需要对比特币升级，直接就可以用。此外，DiceMix可以直接用到许多数字货币上。

比特币下一步计划包括采用Schnorr签名，有一个很大的优势就是可以进行签名聚合，大大缩小交易的体积。

问题：

* 交易费
* 一般用户并不一定恰好有面值为$\beta$的输出。一种解决办法是CoinJoinTx有$n$笔输入，$2n$笔输出，其中$n$笔输出和输入地址一样，面值减去$\beta$，还有$n$笔混币输出面值全部为$\beta$，地址全部为新生成的。
* 双花攻击：在CoinJoinTx上链之前，可能有用户把自己的那笔交易花出去。

解决办法：这些都不是DiceMix的问题，基于CoinJoin的那些混币策略都提出过解决方案。这里就不细述了。

## 其他匿名数字货币（都不够好）

* 完全匿名系统：
  * ZCash：还很不成熟，很难看出是不是会被广泛使用，特别是创世阶段需要一个可信的第三方。
  * CryptoNote：环签名太大，而且不能修剪老的区块。
* 基于Mix的系统：
  * 中心化的Mix：对Mix server的匿名性无法保证，甚至server可能会偷钱。
  * Mixcoin：减轻对Mix server的依赖，但没有解决对Mix server的匿名性，只是减小了server偷钱的危险（但没有完全消除）。
  * Blindcoin：改进了Mixcoin，解决了对Mix server的匿名问题，但server偷钱仍然可能发生。
  * Blindly Signed Contract：需要升级比特币，也就是软分叉，效率也很低，需要每个用户发出四笔交易（意味着很多交易费），其中至少三笔被按顺序确认，即使最冒险的情况下（只等待一个区块的确认），至少也要30分钟。
  * TumbleBit：不需要升级比特币，但也需要两个区块的确认时间。
* 基于P2P网络的系统：
  * CoinParty：只能容忍三分之一的恶意节点。需要无身份的P2P网络，容易遭到Sybil攻击。
  * Xim：能够抵挡Sybil攻击，但需要许多交易（也就是交易费），每个交易都要10分钟确认。

所以最后上场的是我们的Coinshuffle++：不需要升级比特币！不需要中心化的Mix！抗Sybil攻击！两个诚实节点就能容忍任何数量的恶意节点！只要一笔交易！

## 对之前的P2P Mixing Protocol的攻击

之前的P2P Mixing Protocol忽略了一个攻击：简单地把看起来离线的节点排除在外，可能会损害该节点的匿名性，如果这个节点是因为被恶意攻击导致看起来离线。

这里提出对之前的一个协议Dissent shuffle protocol的攻击。这个协议与此攻击有关的步骤如下：在最后一轮通讯中，每个节点公布一个解密密钥，解密出所有匿名化了的密文集合，得到匿名明文集合。

攻击者一直等到最后一轮，在这一轮中截断受害者的密钥，使得其他节点都无法解密密文集合，只有攻击者可以。其他节点以为受害者已经离线了，便重新运行协议，**并且重发之前的消息**。这次协议中受害者完全被离线。顺利完成后，攻击者观察第二次得到的明文集合少了谁，就知道受害者发的是什么消息了。

Dissent shuffle protocol的论文提出的安全性模型太弱了，并没有考虑这一情况。
