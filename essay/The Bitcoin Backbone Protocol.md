# The Bitcoin Backbone Protocol

这篇论文不过是把区块链用数学建模。建模的方式简单而直接。算力被简化为在一轮内每个Party对Hash Oracle的次数访问限制，并且每个Party拥有完全相同的算力。

每个Party被用多带图灵机来定义。每个图灵机有INPUT和RECEIVE和OUTPUT等输入输出带。每个Party的行为被以下三个函数V(), I(), R()定义。这三个函数是与区块链本身无关的，由运行在区块链上的应用来定义，只是需要遵循一些规范。

* V()是用来检查区块链是否合法的（合法的定义由应用决定）。
* I()给定当前状态和区块链，以及INPUT和RECEIVE带，返回需要写入新区块的内容。
* R()给定一条区块链，返回对该链的描述。最简单的实现就是直接返回区块链的内容。

V()，I()，R()的具体实现比较自由，但也需要满足以下限制条件：

* I()返回的区块内容放在原有区块上应该被V()认为合法。
* 对任意两组合法的输入，I()的返回值相同的概率可忽略。

Bitcoin Backbone Protocol将用到三个函数，validate(), maxvalid()和pow()，分别用来验证区块，返回最好链，和计算pow。V()作为参数传给这三个函数，决定它们的具体行为。这就像qsort()的实现只关心quick sort算法，而究竟是按照什么顺序排列完全由传给它的参数compare()函数来决定。

Bitcoin Backbone Protocol是由矿工来执行的，I()和R()为它的参数。I()根据INPUT和RECEIVE带的内容，决定矿工想要放入区块链的内容。每个矿工在每一轮执行一次。每一轮开始时由环境（可以理解为上帝）向每个矿工的INPUT带上写些东西，这些东西主要有两种，READ和(INSERT,value)。矿工调用I()计算新的内容x，调用maxvalid()更新自己的区块链，如果INPUT带上有READ，就调用R()获取自己当前的区块链的描述，写到OUTPUT带上。然后调用pow()计算新的区块B，（如果算出来B）将B添加到原有区块上得到新的链然后广播。

（环境在INPUT带上写的内容究竟是由什么来决定的？RECEIVE带的内容由什么决定？）

Bitcoin Backbone Protocol满足两个性质：

* 公共前缀：任何两个诚实Party的区块链，其中一条去掉最新的k个区块后一定是另一条的前缀
* 区块质量：对任何诚实Party的区块链，任何连续l个区块中诚实区块的比例至少为u

用一堆随机变量$X_i, Y_i, Z_{ijk}$来表示诚实或者不诚实的节点成功挖到区块。利用概率论求出它们的期望值（的一个上/下界）。

所谓的Typical execution，就是指任何一段（长度大于一定值的）连续的区块上，$X,Y,Z$的值离期望不太远。一个execution是typical的概率很高。并且在typical execution中，chain-growth性质满足的概率很高，common-prefix性质满足的概率很高，chain-quality性质满足的概率也很高。

论文接下来的几节讲的是Bitcoin Backbone Protocol的应用，换句话说，就是V()，I()和R()这三个函数的定义范例。

首先是中本聪的解决BA问题的方案，也就是比特币的共识机制。

这里的BA问题指的是对一个比特的共识。中本聪的方案对应到这里来就是每个区块里放一个比特，并且规定合法的区块链每个区块的这个比特都要相同。在模型中，环境每轮都在每个节点的INPUT带上写下同一个比特，也就是希望他们共识达到的比特。这个解决方案中，每个节点只在第一轮从INPUT读取这一比特，以后都从区块链中获取这个比特，而忽略掉INPUT中的比特。这时只要第一个区块中的比特是对的，诚实节点就有极大的概率对正确的比特达到共识。但如果诚实节点的算力只是占多数，第一个区块是敌手控制的概率并非可忽略。所以这个简单的解决方案并不是正确的。

改进的方案不再要求合法的区块链所有比特都相同（那就除了形式外，基本上没要求了），并且每一轮不再忽略INPUT上的这一比特。共识的结果规定为区块链上占大多数的比特。这个解决方案在敌手满足1/3限制的时候可以保证共识结果正确的概率很大。

接着就是给出公共账本的模型。相比于比特币，这也是高度简化版的。每个区块里记录的信息就是一个交易列表，V()函数返回真当且仅当区块链里记录的所有交易构成一个合法的账本。R()函数返回区块链里的账本（如果V()函数返回值为真）。I()函数从INPUT带上读取输入交易列表，找到其中一个最大的子集，使得这个子集放到当前的区块链上不违法。然后返回这个最大子集添上一个随机的“中立”的交易。所谓“中立”的交易是指和其他所有交易都不冲突。

接下来，最后一节修改了整个Bitcoin Backbone Protocol模型，主要有两点改变：首先限定$q=1$，也就是每个节点每轮只能做一次Hash。然后所有公布的消息要等至少$\Delta$轮之后才能被其他节点Receive到。这个修改的模型就被称为有界延迟模型。

在这个新模型下，原先的定义和引理可以进行一些修改之后依然成立。特别的，修改过的typical execution以很高的概率被满足。另外，在typical execution的前提下公共前缀common-prefix和链质量chain-quality属性仍然能以高概率成立。