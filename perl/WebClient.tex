\documentclass[a4paper]{article}
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{listings}
\usepackage{tikz}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\ttfamily\scriptsize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=false,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,	                   % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  columns=flexible,
  keywordstyle=\color{blue},       % keyword style
  otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\DefineShortVerb{\#}

\title{Web Client Programming with Perl}
\author{Yuncong Zhang}
\begin{document}
\maketitle

\section{Introduction to Web and HTTP}

The World Wide Web was developed in 1990 by Tim Berners-Lee at the Conseil Europeen pour la Recherche Nucleaire (CERN).

In 1993 a graphical interface to the Web, name Mosaic, was developed at the University of Illinois at Urbana-Champaign.

In 1994 a new interface to the Web called Netscape Navigator came on the market.
Meanwhile, everyone started developing their own web sites.

\section{Behind the Browser}

\subsection{General structure of HTTP requests}

\tikz{\node[fill=blue!20](1){#Method URI HTTP-version#}}\\
\tikz{\node[fill=red!20](2){#General header#}}\\
\tikz{\node[fill=green!20](3){#Request header#}}\\
\tikz{\node[fill=yellow!20](4){#Entity header#}}\\
\\
\tikz{\node[fill=gray!20](5){#Entity body#}}

Example
\\
\tikz{\node[fill=blue!20](1){#POST /cgi-bin/query HTTP/1.0#}}\\
\tikz{\node[fill=red!20](2){#Referer: http://hypothetical.ora.com/search.html#}}\\
\tikz{\node[fill=green!20](3){#Connection: Keep-Alive#}}\\
\tikz{\node[fill=green!20](4){#User-Agent: Mozilla/3.0Gold (WinNT; I)#}}\\
\tikz{\node[fill=green!20](5){#Host: hypothetical.ora.com#}}\\
\tikz{\node[fill=green!20](6){#Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*#}}\\
\tikz{\node[fill=yellow!20](7){#Content-type: application/x-www-form-urlencoded#}}\\
\tikz{\node[fill=yellow!20](8){#Content-length: 47#}}\\
\\
\tikz{\node[fill=gray!20](9){#querytype=subject&queryconst=numerical+analysis#}}\\

\subsection{General structure of server response}
\tikz{\node[fill=blue!20](1){#HTTP-version Status-code Reason-phrase#}}\\
\tikz{\node[fill=red!20](2){#General header#}}\\
\tikz{\node[fill=green!20](3){#Response header#}}\\
\tikz{\node[fill=yellow!20](4){#Entity header#}}\\
\\
\tikz{\node[fill=gray!20](5){#Entity body#}}

Example
\\
\tikz{\node[fill=blue!20](1){#HTTP/1.0 200 OK#}}\\
\tikz{\node[fill=red!20](2){#Date: Fri, 14 Jan 2016 14:11:51 GMT#}}\\
\tikz{\node[fill=green!20](3){#Server: Apache/2.0#}}\\
\tikz{\node[fill=yellow!20](4){#text/html#}}\\
\tikz{\node[fill=yellow!20](5){#Content-length: 327#}}\\
\tikz{\node[fill=yellow!20](6){#Last-modified: Fri, 14 Jan 2016 14:11:51 GMT#}}\\
\\
\tikz{\node[fill=gray!20](7){#<title>Sample Homepage</title>#}}\\
\tikz{\node[fill=gray!20](8){#src="/images/oreilly_mast.gif"#}}\\

\section{Details of HTTP}

\subsection{HTTP Transaction}
\begin{enumerate}
  \item First, client contacts the server and sends a document request, for example
	\begin{verbatim}
	GET /index.html HTTP/1.0
	\end{verbatim}
  \item Next, client sends optional header information to inform the server of the client's configuration and document preference.
	\begin{verbatim}
	User-Agent: Mozilla/1.1N
	Accept: */*
	Accept: image/gif
	\end{verbatim}
	To end the header section, the clients sends a blank line.
  \item When applicable, the clients sends the data portion of the request, whose length is specified in the header.
  \item The server responds with a status line like
	\begin{verbatim}
	HTTP/1.0 200 OK
	\end{verbatim}
  \item The server supplies header information to tell the client about itself and the requested document.
	\begin{verbatim}
	Date: Fri, 14 Jan 2016 14:11:51 GMT
	Server: NCSA/1.3
	MIME-version: 1.0
	Content-type: text/html
	Content-length: 1029
	Last-modified: Thursday, 13 Jan 2016 18:15:23 GMT
	\end{verbatim}
\end{enumerate}

\subsection{Client request methods}

\begin{itemize}
  \item #GET#: Just retrieve a document.
  \item #HEAD#: Just retrieve the header.
  \item #POST#: Send data to the server, with content in form of
	\begin{verbatim}
	username=name&password=123456
	\end{verbatim}
  \item #PUT#: Store the entity-body at the URL.
  \item #DELETE#: Remove URL.
  \item #TRACE#: View the client's message through the request chain.
  \item #OPTIONS#: Request other options available for the URL.
\end{itemize}

\subsection{Server response codes}

\begin{table}[h]
  \centering
  \begin{tabular}{ll}
	\hline \textbf{Code Range} & \textbf{Response Meaning}\\\hline
	100-199 & Informational \\
	200-299 & Client request successful\\
	300-399 & Client request redirected, further action necessary\\
	400-499 & Client request incomplete \\
	500-599 & Server errors\\ \hline
  \end{tabular}
  \caption{HTTP Response Codes}
  \label{tab:http.res.code}
\end{table}

\begin{itemize}
  \item \textbf{Informational} 
	\begin{itemize}
	  \item #100 Continue#: The client continue waiting.
	  \item #101 Switching Protocols#: The server is switching protocols.
	\end{itemize}
  \item \textbf{Client request successful} 
	\begin{itemize}
	  \item #200 OK#: Successful.
	  \item #201 Created#: A new URL is created.
	  \item #202 Accepted#: The request was accepted but not immediately acted.
	  \item #203 Non-Authoritative Information#: The information is not from original server.
	  \item #204 No Content#: No entity body.
	  \item #205 Reset Content#: The browser should clear the form.
	  \item #206 Partial Content#: The server is returning partial data of the size requested.
	\end{itemize}
  \item \textbf{Redirection} 
	\begin{itemize}
	  \item #300 Multiple Choices#: The URL refers to more than one resource.
	  \item #301 Moved Permanently#: The requested URL is no longer used, and new location is specified in #Location# header.
	  \item #302 Moved Temporarily#: The requested URL has moved temporarily, and new location is specified in #Location# header.
	  \item #303 See Other#: The requested URL can be found at a different URL and should be retrieved by a #GET# on that resource.
	  \item #304 Not Modified#: Response to an #If-Modified-Since# header, the entity-body is not sent.
	  \item #305 Use Proxy#: The requested must be accessed through the proxy in the #Location# header.
	\end{itemize}
  \item \textbf{Client request incomplete} 
	\begin{itemize}
	  \item #400 Bad Request#: Syntax error in client's request.
	  \item #401 Unauthorized#: Not authorized.
	  \item #403 Forbidden#: The request was denied.
	  \item #404 Not Found#: The document at the specified URL does not exist.
	  \item #405 Method Not Allowed#: The method used is not supported by this URL.
	  \item #406 Not Acceptable#: The document is not in a formate preferred by the client.
	  \item #407 Proxy Authentication Required#: The proxy server needs to authorize the request.
	  \item #408 Request Time-out#: The client did not produce a full request within predetermined time.
	  \item #409 Conflict#: The request conflicts with another request or with the server's configuration.
	  \item #410 Gone#: The URL no longer exists.
	  \item #411 Length Required#: The server will not accept the request without a #Content-type#.
	  \item #412 Precondition Failed#: The condition specified by #If# headers in the request evaluated to false.
	  \item #413 Request Entity Too Large#: Entity body too large.
	  \item #414 Request Too Long#: The requested URL is too long.
	  \item #415 Unsupported Media Type#: Entity-body is in an unsupported format.
	\end{itemize}
  \item \textbf{Server error} 
	\begin{itemize}
	  \item #500 Internal Server Error#: Part of the server has crashed.
	  \item #501 Not Implemented#: The requested action cannot be performed by server.
	  \item #502 Bad Gateway#: The server encountered invalid responses from another server.
	  \item #503 Service Unavailable#: The service is temporarily unavailable.
	  \item #504 Gateway Time-out#: A gateway or proxy has timed out.
	  \item #505 HTTP Version Not Supported#: The server does not support the HTTP version used in the request.
	\end{itemize}
\end{itemize}

\subsection{HTTP headers}
\begin{itemize}
  \item \textbf{General Headers}: #Cache-Control#, #Connection#, #Date#, #MIME-version#,
	#Pragma#, #Transfer-Encoding#, #Upgrade#, #Via#
  \item \textbf{Request Headers}: #Accept#, #Accept-Charset#, #Accept-Encoding#,
	#Accept-Language#, #Authorization#, #Cookie#, #From#, #Host#, #If-Modified-Since#,
	#If-Match#, #If-None-Match#, #If-Range#, #If-Unmodified-Since#, #Max-Forwards#,
	#Proxy-Authorization#, #Range#, #Referer#, #User-Agent#
  \item \textbf{Response Headers}: #Accept-Ranges#, #Age#, #Proxy-Authenticate#,
	#Public#, #Retry-After#, #Server#, #Set-Cookie#, #Vary#, #Warning#, #WWW-Authenticate#
  \item \textbf{Entity Headers}: #Allow#, #Content-Base#, #Content-Encoding#,
	#Content-Language#, #Content-Length#, #Content-Location#, #Content-MD5#,
	#Content-Range#, #Content-Transfer-Encoding#, #Content-Type#, #Etag#,
	#Expires#, #Last-Modified#, #Location#, #URI#.
\end{itemize}

\subsection{Persistent Connections}

Persistent connections mean that the network connection remains open during multiple transactions between client and server. 
In HTTP 1.0, the client must use the following header to maintain the connection for an additional request:
\begin{verbatim}
Connection: Keep-Alive
\end{verbatim}

Under HTTP 1.1, persistent connections are default, so clients does not need the #Keep-Alive# parameter,
yet clients must be sure to include the following header in their last transaction:
\begin{verbatim}
Connection: Close
\end{verbatim}

\subsection{Media Types}

For negotiating different data types, HTTP incorporated Internet Media Types,
which look a lot like MIME types but are not exactly MIME types.

The client tells the server which types it can handle, using the #Accept# header.
The server tries to return information in a preferred media type,
and declares the type of the data using the #Content-Type# header.
\begin{verbatim}
Accept: */*
\end{verbatim}
means the client can accept any media type.
\begin{verbatim}
Accept: image/*
\end{verbatim}
means the client accepts any form of image.
While
\begin{verbatim}
Accept: image/gif
\end{verbatim}
means the client accepts only #gif# image.

\subsection{Client caching}

For caching management, HTTP provides a whole set of headers.
There are two general systems: one based on the age of the document,
and the other one based on unique identifiers for each document.

In HTTP 1.0, the #Pragma: no-cache# header tells caching proxies and clients not to cache the document.
Under HTTP 1.1, the #Cache-Control# header supplants #Pragma#,
with several caching directives in addition to #no-cache#.

The client can use #If-Modified-Since# header with the #GET# method.
When using this option, the client requests the server to send the requested information associated with the URL
only if it has been modified since a client-specified time. Example:
\begin{verbatim}
If-Modified-Since: Fri, 15-Jan-2016 06:52:20 GMT
\end{verbatim}
If the server returns code 304, the client could use the cached version of the document.
If the document is newer, the server will send it along with a 200 code.

In HTTP 1.1, entity tags are unique identifiers that can be associated with all copies of the document.
If the server is using entity tags, it sends the document with the #ETag# header.
When the client wants to verify the cache,
it uses the #If-Match# or #If-None-Match# headers to check against the entity tag for that resource.

\subsection{Retrieving document}

There are three common ways that a client can retrieve data from the entity-body of the server's response:
\begin{itemize}
  \item The first way is to get the size of the document from the #Content-length# header,
	and then read in that much data.
  \item When the size of the document is too dynamic for a server to predict,
	the #Content-length# header is omitted.
	The client reads in the data portion of the server's response until the server disconnects the network connection.
  \item Another header could indicate when an entity-body ends, like HTTP 1.1 #Transfer-Encoding# header with the chunked parameter.
\end{itemize}

In HTTP 1.1, the client does not have to get the entire entity-body at once,
but can get it in pieces, if the server allows by the #Accept-Ranges# header.
\begin{verbatim}
HTTP/1.1 200 OK
Accept-Ranges: bytes
\end{verbatim}
then the client can request the data in pieces, like so:
\begin{verbatim}
GET /largefile.html HTTP/1.1
Range: 0-65535
\end{verbatim}
When the server returns the specified range,
it includes a #Content-Range# header to indicate which portion of the document is being sent,
and also how long the file is.
\begin{verbatim}
HTTP/1.1 200 OK
Content-range: 0-65535/83028576
\end{verbatim}

\subsection{Referring documents}

The #Referer# header indicates which document referred to the one currently specified in this request.
For example, if the client sends \url{www.ora.com} the following
\begin{verbatim}
GET /contact.html HTTP/1.0
Accept: */*
\end{verbatim}
the server may responds with:
\begin{verbatim}
HTTP/1.0 200 OK
Date: Fri, 15-Jan-2016 07:15:23 GMT
MIME-version: 1.0
Content-type: text/html

<h1>Contact Information</h1>
<a href="http://sales.ora.com/sales.html">Sales Department</a>
\end{verbatim}
The user clicks on the hyperlink, then sends \url{sales.oral.com} the following
\begin{verbatim}
GET /sales.html HTTP/1.0
Accept: */*
Referer: http://www.ora.com/contact.html
\end{verbatim}

\subsection{Client and server identification}

Clients identify themselves with #User-Agent# header.
\begin{verbatim}
User-Agent: Mozilla/1.1N (Macintosh; I; 68K)
User-Agent: HTML-checker/1.0
\end{verbatim}

Servers identify themselves with the #Server# header.

\subsection{Authorization}

An #Authorization# header is used to request restricted documents.
First, client requests document without #Authentication#,
then denied by server, with #WWW-Authentication# header describing the authorization method.
Then client requests the document again, but with #Authentication# header.

For example, the client may send
\begin{verbatim}
GET /sample.html HTTP/1.0
User-Agent: Mozilla/1.1N (Macintosh; I; 68K)
Accept: */*
\end{verbatim}
The server then responds
\begin{verbatim}
HTTP/1.0 401 Unauthorized
Date: Sat, 15-Jan-2016 07:29:38 GMT
Server: NCSA/1.3
MIME-version: 1.0
Content-type: text/html
WWW-Authenticate: BASIC realm=``System Administrator''
\end{verbatim}
The client now seeks authentication information,
by prompting to the user or searching on the hard drive.
After encoding the data appropriately for the BASIC authorization method,
the client responds with proper authentication
\begin{verbatim}
GET /sample.html HTTP/1.0
User-Agent: Mozilla/1.1N (Macintosh; I; 68K)
Accept: */*
Authorization: BASIC d2VibWFzdGVyOnpycW1hNHY=
\end{verbatim}
The server checks the authentication, and sends the requested data.

\subsection{Cookies}
When a server identifies a new user, it adds the #Set-Cookie# header to its response.
The client is expected to save that in disk.
In subsequent requests to that URL,
the client should include the cookie information using the #Cookie# header.

\section{The Socket Library}

\subsection{A typical conversation over sockets}

The basic idea behind sockets,
is that the server sits and waits for connections over the network to a specific port.
When a client connects to that port, the server accepts and converses with the client,
using whatever protocols like HTTP, NNTP, SMTP.

Initially, the server uses the #socket()# system call to create the socket,
then #bind()# the socket to a particular port on the host.
The server then #listen()# to the port and #accept()# incoming connect from that port.

On the other hand, the client also create #socket()#,
then #connect()# to the remote socket on a specific host and port.
After the server #accept()# the connection,
they can both use #sysread()# and #syswrite()# to speak to each other.
Finally, either the client or server #close()# or #shutdown()# the connection.

\subsection{Using the socket}

The socket library is part of the standard Perl distribution.
Include the socket module like this:
\begin{lstlisting}[language=Perl]
use Socket;
\end{lstlisting}
To create a socket,
\begin{lstlisting}[language=Perl]
socket(SH, PF_INET, SOCK_STREAM, getprotobyname('tcp')) || die $!;
\end{lstlisting}
where #SH# is the file handler associated with the newly created socket,
#PF_INET# indicates the Internet Protocol while #getprotobyname('tcp')# indicates that TCP runs on top of IP.
#SOCK_STREAM# indicates that the socket is stream-oriented.

If the socket call fails, the program should #die()# using the error message found in #$!#.

Connect the server by

```perl
my $sin = sockaddr_in(80,inet_aton('www.bing.com'));
connect(SH,$sin) || die $!;
```

where #sockaddr_in()# accepts a port number and a 32-bit IP address,
and return a data structure containing information for an address used by #connect()#.
The #inet_iton('www.bing.com')# looks up the IP address of the given hostname by DNS.

Next, write to the socket by
\begin{lstlisting}[language=Perl]
$buffer = "Hello world!";
syswrite(SH, $buffer, length($buffer));
\end{lstlisting}

An easier way is to use #print#.
\begin{lstlisting}[language=Perl]
select(SH);
$|=1;	# set $| to non-zero to make selection autoflushed
print SH "Hello world!";
\end{lstlisting}

Then we read the data from socket.
\begin{lstlisting}[language=Perl]
sysread(SH, $buffer, 200); # read at most 200 bytes from SH and save to $buffer
\end{lstlisting}

To read a line at a time from the file handle,
\begin{lstlisting}[language=Perl]
$buffer = <SH> # Read a line from $buffer
\end{lstlisting}

Finally, close the socket by
\begin{lstlisting}[language=Perl]
close(SH);
\end{lstlisting}

\subsection{The complete client connection code}

We define a function #open_TCP# in a file #tcp.pl#.
\lstinputlisting[language=Perl]{tcp.pl}

Then we use this function by
\lstinputlisting[language=Perl]{client1.pl}

\subsection{Parsing a URL}

Let's start by defining a function for parsing URL.
\lstinputlisting[language=Perl]{web.pl}

We can use it to implement a hypertext version of the UNIX #cat# command.
\lstinputlisting[language=Perl]{hcat.pl}

We didn't use the second function #grab_urls()# in #hcat.pl#.
This function takes two arguments, the first is the document content,
and the second is a hash mapping tags to the desired parameters,
for example, #('img','src','body','background')#,
since the #src# parameter of an #image# tag and the #background# parameter of a #body# tag are both URLs.
We can use this function to implement a HTTP version of UNIX #grep# command, #hgrepurl#.
\lstinputlisting[language=Perl]{hgrepurl.pl}

\section{The LWP Library}

The LWP library is a module for WWW access in Perl,
which encapsulate common functions for a web client or server.
LWP is much faster and cleaner than using sockets.

\subsection{Some simple examples}

Simply get a document specified by a URL.
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
use LWP::Simple;

print (get $ARGV[0]); # $ARGV[0] is the first command line argument
\end{lstlisting}

It can even be simpler!
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
use LWP::Simple;

getprint($ARGV[0]); # $ARGV[0] is the first command line argument
\end{lstlisting}

You can use the HTML library to parse the HTML.
\begin{lstlisting}[language=Perl]
#!/usr/bin/perl
use LWP::Simple;
use HTTP::Parse;

print parse_html(get ($ARGV[0]))->format; # $ARGV[0] is the first command line argument
\end{lstlisting}

LWP can extract hyperlinks referenced inside an HTML page.

\lstinputlisting[language=Perl]{showlink.pl}

\subsection{LWP modules}

There are eight main modules in LWP: File, Font, HTML, HTTP, LWP, MIME, URI and WWW.
\begin{itemize}
  \item \textbf{File}: parses directory listings.
  \item \textbf{Font}: handles Adobe Font Metrics.
  \item \textbf{HTML}: handles HTML syntax trees.
  \item \textbf{HTTP}: describes client requests, server responses, and dates, and computes a client/server negotiation.
  \item \textbf{LWP}: the core of all web client programs.
  \item \textbf{MIME}: converts to/from base 64 and quoted printable text.
  \item \textbf{URI}: escape URI, specify or translate relative URLs to absolute URLs.
  \item \textbf{WWW}: determine if a server's resource is accessible via the Robot Exclusion Standard.
\end{itemize}

\subsubsection{The LWP module}

There are 10 classes in all within the LWP module: Debug, IO, MediaTypes, MemberMixin, Protocol, RobotUA, Simple, Socket, TKIO, UserAgent.

We are mainly interested in Simple, UserAgent, and RobotUA classes.

\begin{itemize}
  \item \textbf{Simple}: quickly design a web client without complex behaviors.
	\begin{itemize}
	  \item #get($url)#: returns the content of the URL specified by #$url#.
	  \item #head($url)#: returns the header information of the URL specified by #$url#.
	  \item #getprint($url)#: print the content of the URL specified by #$url#.
	  \item #getstore($url,$file)#: store the content of the URL specified by #$url# to file specified by #$file#.
	  \item #mirror($url,$file)#: store the content of the URL specified by #$url# to file specified by #$file#, only if modified.
	  \item #is_success($rc)#: Given a status code from #getprint()#, #getstore()#, or #mirror()#, returns true if the request was successful.
	  \item #is_error($rc)#: Given a status code from #getprint()#, #getstore()#, or #mirror()#, returns true if the request was not successful.
	\end{itemize}
  \item \textbf{UserAgent}: Create an agent using #new LWP::UserAgent# and #request()# a server, return the result of the query.
  \item \textbf{RobotUA}: A subclass of #LWP::UserAgent#, requesting resources in an automated fashion.
\end{itemize}

\subsubsection{The HTTP module}

The HTTP module specifies HTTP requests and responses,
plus some helper functions to interpret or convert data related to HTTP requests and responses.
There are eight classes in HTTP module: Daemon, Date, Headers, Message, Negotiate, Request, Response, Status.

\subsubsection{The HTML module}

The HTML module provides an interface to parse HTML into an HTML parse tree,
traverse the tree, and convert HTML to other formats.
There are eleven classes in the HTML module:
AsSubs, Element, Entities, FormatPS, FormatText, Formatter, HeadParser, LinkExtor, Parse, Parser, TreeBuilder.

\subsubsection{The URI module}

The URI module contains functions and modules to specify and convert URIs.
There are only two classes within the URI module: AsSubs, Element.

\subsection{Using LWP}

First, let's revisit the simple #getprint# script and make it robust,
using the #LWP::UserAgent# module instead of #LWP::Simple#.
We save it in file #hcat_plain.pl#.
\lstinputlisting[language=Perl]{hcat_plain.pl}
If it fails to get the web page, an error page will be printed.
It could even follow redirections automatically.

If we use #LWP::RobotUA# instead,
\lstinputlisting[language=Perl]{hcat_robot.pl}

\section{LWP Examples}

\lstinputlisting[language=Perl]{hcat_ua.pl}
\lstinputlisting[language=Perl]{hgrepurl_ua.pl}
\lstinputlisting[language=Perl]{fedex.pl}
\lstinputlisting[language=Perl]{ck.pl}

\section{Graphical Examples with Perl/Tk}

\subsection{Introduction to Tk}

Tk gives your browser a Graphical User Interface.
Here is a simple ``Hello World'' program for Tk.
\lstinputlisting[language=Perl]{hello.pl}
When you run this script, a small window will show up with only a button on it.
Press the button and the program will exit.

Note: the #=># simple is functionally the same to comma (#,#).
It just makes it easier to detect ``pairs'' of items.

\subsection{Examples}

The following example is a dictionary program looking up a word on a website.
\lstinputlisting[language=Perl]{xword.pl}
The following example is a graphical #httping#.
\lstinputlisting[language=Perl]{webping.pl}

\end{document}
