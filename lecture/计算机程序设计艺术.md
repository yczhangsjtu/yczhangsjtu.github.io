# 计算机程序设计艺术

## 排序算法

### 排序的乘法
每个排序用多个不相交的cycle表示。两个排序合并到一起后，该算法用来将所有cycle合并为新的不相交的cycle集合。

1.3.3节给出了一个简单的算法，很容易用汇编实现（虽然不知道为什么是对的），将输入（连同左右括号）当做字符串来处理。

只需要关心这里有一个算法，暂时不关心这个算法为什么是对的，更不要深看MIX汇编程序。这个算法还是很接近人的思维的，但计算机的思维和人不同，所以可以设计更加适合计算机的算法。

另一个算法初始化一个单位排序，然后从右往左扫一遍输入，每一次调整一下排序，读完之后就得到了最终的排序。然后再用一个算法输出成cycle集合的形式。

### 求一个排序的逆
如果允许用输入两倍的空间，这是很容易实现的。如果要像快排一样就地解决，就需要一个巧妙的算法了。1.3.3节给出了两个算法，其中第二个算法更难一眼看出是对的。

### Canonical形式
把所有大小为一的cycle包括进来，然后每个cycle的最小元素放在前面，最后按照第一个元素从大到小排列，就得到了一个排序的Canonical形式。这种形式的好处是去掉括号之后还能恢复，也就是说对没有括号的序列只有一种插入括号的方式能得到Canonical形式。这种方式就是在每个“左边没有更小的”元素前面插入括号。

因为Canonical形式去掉括号后也是有N阶乘个，这就给出了排序的两种表达方式之间的一种一一对应。这种一一对应可以用来解决非常多的计数问题，把“多少个cycle”这样的问题转化为“多少个左边没有更小的元素”这样更容易解决的问题。

## 一些概念

### Subroutine

本节似乎并没有提出任何关于Subroutine的新思想。

### Coroutine

Coroutine就像是用一种平等的观念看待Routine和Subroutine的关系。从Subroutine回到Main函数，可以看做从Subroutine调用Main而不是简单的结束。两个Coroutine之间的关系即为相互调用来调用去，只不过每次被调用的时候并不是从头开始，而是从上次离开的地方接着运行。

## 数据结构

这里的内容其实都已经是计算机系的基础课内容了，只是用一种更古老的方式描述出来（当时C语言还不流行？）。以下仅列出一些数据结构课上并不常见的内容。

### 拓扑排序

把偏序嵌入全序。

最简单的算法：找出没有前序的元素拿出来。重复这个过程，直到偏序为空。拿出来的顺序就是个符合要求的全序。

### 矩阵的表示

稀疏矩阵：非零元素指向左边和上边的非零元素。

这里只给出了一个算法pivot step，指对矩阵中的四个元素进行的一种操作，是在矩阵求逆等算法中的一个重要操作。

## 树

树有非常多的表示方法，也有很多具体的应用可以表示成树的结构。

在二叉树中少于两个孩子的节点上增加thread，可以得到threaded tree。所谓的thread即指向中序遍历中的前一个节点和后一个节点的指针。注意如果有左子树或又子树，那么左右子树的根节点本身就是它在中序遍历中的前一个节点或后一个节点。因此，在threaded tree中所有节点都恰好有两个指针，指向中序遍历中的前后节点。

两棵树相似如果它们的结构相同。两棵树等价如果它们相似并且每个节点存储的信息相同。

两棵树的前序遍历如果对应位置的节点都同时有或没有左子树或右子树，则两棵树相似。

任何森林都可以用二叉树进行唯一的表示。实际上它们存在一一映射。根据对二叉树的前序、中序和后序遍历直接定义对森林的相应遍历。

对用二叉树表示的算式，有算法来求它的导函数，根据一些现成的公式。

除了最直接的用左右孩子的指针表示数的结构外，树有很多种表示方法。一种方法是线性表。

有些应用要求节点增加一个指向父节点的指针。有的时候节点可以只有一个指向父节点的指针，一个典型的应用就是并查集。

