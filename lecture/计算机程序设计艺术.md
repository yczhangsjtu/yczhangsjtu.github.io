# 计算机程序设计艺术

## 排序算法

### 排序的乘法
每个排序用多个不相交的cycle表示。两个排序合并到一起后，该算法用来将所有cycle合并为新的不相交的cycle集合。

1.3.3节给出了一个简单的算法，很容易用汇编实现（虽然不知道为什么是对的），将输入（连同左右括号）当做字符串来处理。

只需要关心这里有一个算法，暂时不关心这个算法为什么是对的，更不要深看MIX汇编程序。这个算法还是很接近人的思维的，但计算机的思维和人不同，所以可以设计更加适合计算机的算法。

另一个算法初始化一个单位排序，然后从右往左扫一遍输入，每一次调整一下排序，读完之后就得到了最终的排序。然后再用一个算法输出成cycle集合的形式。

### 求一个排序的逆
如果允许用输入两倍的空间，这是很容易实现的。如果要像快排一样就地解决，就需要一个巧妙的算法了。1.3.3节给出了两个算法，其中第二个算法更难一眼看出是对的。

### Canonical形式
把所有大小为一的cycle包括进来，然后每个cycle的最小元素放在前面，最后按照第一个元素从大到小排列，就得到了一个排序的Canonical形式。这种形式的好处是去掉括号之后还能恢复，也就是说对没有括号的序列只有一种插入括号的方式能得到Canonical形式。这种方式就是在每个“左边没有更小的”元素前面插入括号。

因为Canonical形式去掉括号后也是有N阶乘个，这就给出了排序的两种表达方式之间的一种一一对应。这种一一对应可以用来解决非常多的计数问题，把“多少个cycle”这样的问题转化为“多少个左边没有更小的元素”这样更容易解决的问题。

## 一些概念

### Subroutine

本节似乎并没有提出任何关于Subroutine的新思想。

### Coroutine

Coroutine就像是用一种平等的观念看待Routine和Subroutine的关系。从Subroutine回到Main函数，可以看做从Subroutine调用Main而不是简单的结束。两个Coroutine之间的关系即为相互调用来调用去，只不过每次被调用的时候并不是从头开始，而是从上次离开的地方接着运行。

## 数据结构

这里的内容其实都已经是计算机系的基础课内容了，只是用一种更古老的方式描述出来（当时C语言还不流行？）。以下仅列出一些数据结构课上并不常见的内容。

### 拓扑排序

把偏序嵌入全序。

最简单的算法：找出没有前序的元素拿出来。重复这个过程，直到偏序为空。拿出来的顺序就是个符合要求的全序。

### 矩阵的表示

稀疏矩阵：非零元素指向左边和上边的非零元素。

这里只给出了一个算法pivot step，指对矩阵中的四个元素进行的一种操作，是在矩阵求逆等算法中的一个重要操作。