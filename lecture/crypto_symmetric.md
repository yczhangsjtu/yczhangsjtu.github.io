# 对称密钥密码学

## 有效的算法和可忽略的量

* 有效的算法就是“概率多项式时间”（PPT）可执行的算法
    *  随机性在密码学中是有必要的
    *  能够模拟的现实中的敌手的类型扩大
*  对任意多项式 $p(x)$ ，当 $n$ 足够大时都有 $f(n)<\frac{1}{p(n)}$ ，则 $f(x)$ 是可忽略的。
*  计算安全：没有多项式时间的攻击者能以不可忽略的概率攻击成功。

## 对称加密的 Semantic Security （语义安全）

* 不可区分安全性
```sequence
adv->chal: m0, m1
chal->adv: c=Ek(mb)
```

* 经过上述过程后，对手 A 无法判断收到的是 $m_0$ 还是 $m_1$ 加密的信息，这称为**不可区分安全**的。

* Semantically secure 是指攻击者从密文中获得关于明文的**任意部分信息**的概率都是可忽略的
* 弱化版本： 攻击者看到密文与否，输出的关于明文的信息的概率是**几乎一样**的
* 更弱版本：攻击者看到密文后，**几乎不能**输出明文的一比特信息

* Semantically secure 是一个非常强非常令人信服的安全保证。但不可区分性更容易证明。
* 对于对称密码来说，这两者是等价的。因此，通常使用不可区分性做证明。

## 规约证明的基本技巧

* 目的：证明不存在攻击者能够在PPT的时间里，以不可忽略的概率攻击成功
* 前提：假设存在公认的困难问题
* 方法：反证法，即若攻击方案的一个实例成功，则公认困难问题的一个实例可以被解决

* 必须使用困难问题：如果存在安全性不依赖于任何困难问题，则可以证明 $P\neq NP$。

## 伪随机性

* 一个长度为 $l$ 的串是伪随机的，是指没有PPT的攻击者可以以不可忽略的概率区分一个给定串是从D上采样的，还是从长度为 $l$ 的串上随机采样的。
* 伪随机发生器（PRG）：确定性的多项式时间算法，输入短的真随机种子，输出长的伪随机序列。
* 任意PPT的算法，都不能以不可忽略的概率区分PRG产生的序列和等长的真随机序列。
* 尚无证明PRG是否存在，但应用中常假设PRG存在。
* 由单向函数（OWF）存在的假设可以构造PRG。

* 由单向置换（OWP）可以构造PRG
    * Hard core: 对函数 $f$，其 hard core bit 定义如下：
        *  给定 $x$，$hc(x)$ 可以在多项式时间计算出来
        *  对任意PPT算法 $\mathcal{A}$ 都有
    
        $$ Pr_{x\leftarrow\{0,1\}^n}[\mathcal{A}(1^n,f(x))=hc(x)]\leq\frac{1}{2}+negl(n) $$

        即任何攻击者从 $f(x)$ 中猜出 $hc(x)$ 的概率和 $1/2$ 最多差一个可忽略的量。
    * 任何单向函数都存在 hard core bit？目前还是公开命题。
    * 稍弱的证明是对每个单向函数 $f$ 能找到一个单向函数 $g$ 以及 $g$ 的 hard core bit。其中 $g$ 的构造如下
        
        $$g(x,r) = f(x)||r, gl(x,r) = \bigoplus_{i=1}^n x_i\cdot r_i$$
        
    * 若有随机置换 $P$，令 $G(s) = P(s) || hc(s)$，就得到了能够扩张一个比特的伪随机发生器。
    
## 用 PRG 代替 OTP

* 密钥：$k$ 为PRG的随机种子
* 加密：$c=m\oplus G(k)$
* 解密：$m=c\oplus G(k)$