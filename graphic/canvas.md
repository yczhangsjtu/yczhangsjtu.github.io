---
title: Canvas
---

# Canvas

这里主要以Javascript的Canvas为例进行讲解。

## Canvas和SVG

SVG图形是矢量图形，Canvas上画的图形是点阵的。

SVG并不只是一种图片文件格式（.svg结尾的），而是一种画图程序的实现思想。比如Python的tkinter的Canvas，应该就是用SVG的。

SVG就像把剪纸贴在纸上，随时可以移动，用剪纸本身的色彩构成图像。点阵图形则像是在剪纸上涂上油彩，在画纸上按一下就拿开，剪纸的形象就永远固定在那里了。

HTML是可以用代码来写SVG图像的。`<svg>`标签定义一个绘图环境，所有图形也是用HTML标签来画的。

但`circle`和`rect`这些标签其实HTML是没有的，需要`svg`环境来定义。但`svg`环境也没那么大空去写怎么定义，所以要引用一个URL，http://www.w3.org/2000/svg，叫做XML namespace（属性名就是xmlns）。这就像C++的`using namespace`一样。

Javascript可以通过操作DOM元素的方式，操作这些SVG图形，控制它们的属性（长宽位置等等），实现动画。

DOM对象Canvas并没有直接支持`fillRect`之类的画图操作。它只是提供一个上下文`getContext`。目前的Canvas支持两种上下文，一个是2D的，一个是3D的。

## Filling and stroking

Fill是指画中间，stroke是指画边。

画空心矩形就用strokeRect，画没有边只有中间纯色的矩形就用fillRect。画一个带不同颜色边的矩形就两个都用。

Javascript里面，画笔的颜色等等都是在上下文环境中的，所以调用画图参数的时候只要坐标参数就够了，但要提前用指定颜色（也就是更改上下文的属性）。与之对应的，python的tkinter的canvas就要每次调用都指定好fill颜色和stroke颜色等属性。相比之下，Windows的GDI有点类似于处于中间的某种方式：绘制之前制作一个画笔对象，把颜色属性等配置好了，绘制的时候把画笔当参数传进去，其他参数只需要指定坐标就行了。

编程上，可以通过封装的方式在这两种方式间互换。不过一般没这个必要。一个代码更加紧凑，一个代码更加简洁，各有利弊。

## Path

Path不是对象，而是用代码描述的一个过程。这个过程有开始有结束。

用`beginPath()`方法开始Path，经过一系列操作得到一个Path，最后用`stroke()`画出Path，或者用`fill()`方法把Path包围的区域封闭起来。

中间的操作有两种方式：`moveTo(x,y)`，把笔提起来走到指定位置（简单地说，飞过去）；还有`lineTo(x,y)`，画一条直线走过去。最后`stroke()`的时候，只有`lineTo()`留下的痕迹才会被画上。

* 【实验】如果中间多次使用moveTo，画出一条不连续的Path，最后fill会怎样？会不会自动按顺序把片段连接起来？
  * 不会。什么都没有画。
* 【实验】可不可以连续fill()或stroke()，换颜色之后再来一次？
  * 完全可以。这两个方法并没有结束Path。而beginPath只是清空Path，重新开始画而已。上下文中这个Path是一直存在的。
  * 实际上，不beginPath也是可以的。

类似有Path功能的有Flash支持的Action Script。

## Curves

绘制Curve是Path功能的一部分。画直线是`lineTo`，它是`curveTo`，只不过比起直线来它有不止一种确定曲线的方式，所以前面加上些修饰词。

比如二次曲线，`quadraticCurveTo`，需要额外指定一个控制点，画出来的曲线首尾都和经过控制点的折线相切。

更高级的是Bezier曲线。它需要两个控制点。实际上二次曲线就是二次Bezier曲线，而bezierCurveTo不过是三阶Bezier曲线。二次曲线只需一个控制点，直接决定曲线首尾的切线方向，而三阶曲线多一次灵活性，控制点远近可以影响曲线大小，控制点远的时候可以把曲线“拉”过去。

最后是画弧线，`arcTo`。它需要一个控制点，一个目标，和二次曲线一样，但最后还要一个参数，就是弧线的半径。当半径是零的时候，结果是一条经过控制点的折线。当半径增大的时候，折点处变成一个圆角。只不过，这个方法诡异的是，它只画弧线的部分，以及连接起始点和弧线起点的直线，而这个方法结束后当前的画笔位置就落到弧线的终点上了，而不是真正的终点。换句话说，当前的位置和目标点只不过是指定了两个方向，让它来画曲线而已，然后顺便把当前位置和曲线起点连上了，但曲线中点和目标点没有连，你可以自己手动lineTo过去。

如果要画一个圆，可以调用四次`arcTo`，每次画九十度。不过还有一个`arc`方法（虽然不带`To`但也是画路径的），指定圆心，半径，和起始角度与最终角度。这个方法也相当于一个`lineTo`加上一段弧线，最后位置落到圆弧的终点上。

## Text

对于文字，Javascript也提供了一对fill和stroke，只不过一般只会用到fill，stroke大概只有在制作艺术字的时候才会用得到。`fillText`方法很简单，只要三个参数，文字内容和位置。不过它额外要求设置上下文的一个`font`属性。这个`font`属性同时设置了字体大小和字体类型。在其他语言中，一般是两个参数font size和font family。这两个合起来为一个font。有些语言把Font做成了类，比如Java和GDI。但归根结底，font就包含这两样东西（一些bool值比如粗体、斜体、下划线等不是太重要）。在Javascript里，能用字符串表示的就用字符串表示了（所以它才慢？），而在C/C++这种语言里，font family这种东西肯定要用const int或者enum之类的事实上的整型来处理，而Javascript连字体大小都用字符串了，因为不仅要有一个数字，还要单位，和font family放到一起作为一个font，用空格隔开。算得上是对用户最友好的字体设置方式了。如果要粗体、斜体等，对应的单词直接拼上去。比如`"italic small-caps bold 12px arial"`。

此外，对齐方式也是在上下文中设置的，水平方向上（`textAlign`属性）有左对齐居中右对齐，竖直方向上（`textBaseline`属性）有上对齐下对齐和居中。想想这些如果都要当做参数传的话得多麻烦，一行函数调用会写很多，而且没必要（一般来说，一个程序里大部分地方写字的对齐方式，都是一样的，设置一次就够了）。

## Images

Javascript画的图片对象可以直接是img类型的DOM对象。`drawImage`的参数也很简单，img对象，和位置。它也可以传递额外的参数。如果参数个数为九个，则第一个参数为img对象，接下来四个参数是从原图中截取一个矩形出来，最后四个参数是指定放到canvas上的哪个矩形上（可能会做伸缩变形）。

## Transformation

通过scale, rotate等方法改变坐标系，绘制的内容都和新的坐标系对齐，达到变换的效果。

类似于OpenGL，这种变换是存储在一个堆栈里的，可以保存和恢复。
