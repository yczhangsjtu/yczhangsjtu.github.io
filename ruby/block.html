<html>
<head>
<title>Computer Technology and Skills</title>

<link href="/css/website.css" type="text/css" rel="stylesheet"/>
<link href="/css/bootstrap.min.css" type="text/css" rel="stylesheet"/>

</head>

<body>

<div class="document">
<h2>Ruby Blocks</h2>


<h3>Diving into blocks</h3>

Blocks are often the first Ruby-ism that new Rubyists run into, and are confused by.
What are blocks? Why do they exist? How do I use them?
<br><br>
I'll do my best to answer all these questions and more in this lesson.

<h3>What are blocks?</h3>

Blocks aren't unique to Ruby.
The official (language agnostic) definition of blocks is "A section of code which is grouped together."
Of course, I'm guessing this doesn't help you much.
<br><br>
A simpler way to describe blocks is "A block is code that you can store in a variable like any other object and run on demand."
<br><br>
Let me help you build a mental model for this by showing you some code,
then refactoring it to a block in Ruby.
We can start by writing some code that does something trivial, but meaningful. 
<pre>
puts 5+6
</pre>
Sweet. That works!
However, this only covers the first part of the definition - it's a section of code.
It isn't "grouped together" though, nor is it stored in a variable.
<br><br>
Let's work on it some more to make it more generic before we "group it." 
<pre>
a = 5
b = 6
puts a+b
</pre>
Great. That works - we've replaced the numbers with variables.
The code that does the addition, however, is still not stored in a variable.
<br><br>
Let's make it happen! 
<pre>
addition = lambda {|a,b| return a+b}
puts addition.call(5,6)
</pre>
And there you have it all nice and grouped - a block!
<br><br>
The 'lambda' keyword is what is most commonly used to create a block in Ruby.
There are other ways to do it, but lets keep things simple for now.
<br><br>
At this point if you're thinking "Wait, that looks pretty much like a method,
except there's no class or object" then you're absolutely right.
Try thinking of it like this: A block is like a method, but one that isn't associated with any object.
<br><br>
Let's examine blocks more closely.
<br><br>
Are blocks objects? Yes, like almost everything else in Ruby, they are.
<pre>
empty_block = lambda { }
puts empty_block.object_id
puts empty_block.class
puts empty_block.class.superclass
</pre>
As you can see, the block we just created has an <font face="Courier">object_id</font>,
belongs to the class <font face="Courier">Proc</font> (which is what a block is called in Ruby),
which is itself a subclass of <font face="Courier">Object</font>.
<br><br>
We can even flip the definition around and define methods in terms of blocks.
A method is simply a block bound to an object, with access to the object's state.
<br><br>
Let me illustrate the idea by reverse engineering a Ruby method to produce a block.
Here's a more traditional approach to the previous problem (and please forgive my crappy object modeling):
<pre>
class Calculator
    def add(a,b)
        return a+b
    end
end

puts Calculator.new.add(5,6)
</pre>
There, that works as you'd expect. Now lets take it further.
<pre>
class Calculator
    def add(a,b)
        return a+b
    end
end

addition_method = Calculator.new.method("add")
addition = addition_method.to_proc

puts addition.call(5,6)
</pre>
And there you have it - a regular, old fashioned method converted to a fancy-pants block!

<h3>Yielding to Blocks</h3>
As you use blocks, you will discover that the most common usage involves passing exactly one block to a method.
This pattern is extremely popular in the Ruby world, and you'll find yourself using it all the time.
<br><br>
Ruby has a special keyword and syntax to make this pattern easier to use, and yes, faster!
Meet the <font face="Courier">yield</font> keyword, Ruby's implementation of the most common way of using blocks.
<br><br>
Here's an example that uses regular block syntax.
<pre>
def calculation(a, b, operation)
    operation.call(a, b)
end

puts calculation(5, 6, lambda { |a, b| a + b }) # addition
puts calculation(5, 6, lambda { |a, b| a - b }) # subtraction
</pre>
As you can see, the <font face="Courier">calculation</font> method accepts two numbers and a block that can perform a mathematical operation.
<br><br>
Let's now do this using <font face="Courier">yield</font>:
<pre>
def calculation(a, b)
    yield(a, b)
end

puts calculation(5, 6) { |a, b| a + b } # addition
puts calculation(5, 6) { |a, b| a - b } # subtraction
</pre>
As you can see, the results are identical.
Feel free to play around with the example to get a better feel for the new syntax.
<br><br>
Let me call out how the example using <font face="Courier">yield</font> is different from the regular approach.
<ul>

<li>The block is now no longer a parameter to the method.
The block has been implicitly passed to the method - note how it's outside the parentheses.</li>
<li>Yield makes executing the block feel like a method invocation within the method invocation rather than a block that's being explicitly called using <font face="Courier">Proc#call</font>.</li>
<li>You have no handle to the block object anymore - yield "magically" invokes it without any object references being involved.</li>
</ul>

Note that blocks can be passed implicitly to methods without any parameters.
The syntax remains the same.
<br><br>
Here's an example where neither the method nor the block take any parameters.
<pre>
def foo
    yield
end
foo { puts "sometimes shortcuts do get you there faster"  }
</pre>

<h3>Magic Blocks</h3>
I call <font face="Courier">yield</font> "magical" because every object oriented rule in Ruby is suspended for this special mode of block invocation.
<br><br>
Let's see what rules are bent, and what broken.
<br><br>
1) Yield is not a method
<pre>
def foo
    puts yield
    puts method(:foo)
    # uncomment the following line and see what happens! 
    # puts method(:yield)
end

foo { "I expect to be heard." }
</pre>
As you can see, the program blows up with an exception on the last line in the method.
Clearly <font face="Courier">yield</font> calls the block,
the <font face="Courier">method</font> method correctly returns the object that represents
<font face="Courier">foo</font> as expected, but then blows up on <font face="Courier">yield</font>.
So <font face="Courier">yield</font> isn't really a method even though it looks like one (turns out, it's a keyword).
<br><br>
2) Objects are abandoned
<br><br>
Everything in Ruby is an object.
Now where's the object that represents the block?
How is yield getting access to it and seemingly invoking the call method on it?
<br><br>
We don't know. As programmers using the language, all we can tell is that the normal rules have been suspended.
<br><br>
We'll see exactly why all these rules are broken later in this lesson.
<br><br>
With implicit blocks, it's hard to be sure if a block has actually passed.
Doing a <font face="Courier">yield</font> when there's no block can have unfortunate consequences -
an exception (a <font face="Courier">LocalJumpError</font>) with the message "no block given" is raised .
<pre>
def foo
    yield
end

foo
</pre>
To defend against this outcome, Ruby offers the <font face="Courier">block_given?</font> method that tells you if a block has been passed to a method implicitly.
Make the call to yield conditional on this method returning <font face="Courier">true</font> and you'll be fine.
<pre>
def foo
    yield if block_given?
end
</pre>
</div>
</body>

</html>
